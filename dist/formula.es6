// Copyright 2015 JC Fisher

// map an array to a new array
function map(array, func) {
  return array.map(func)
}

/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,4],$V1=[1,5],$V2=[1,6],$V3=[1,7],$V4=[1,8],$V5=[1,11],$V6=[1,12],$V7=[1,13],$V8=[1,14],$V9=[1,15],$Va=[1,16],$Vb=[1,24],$Vc=[1,18],$Vd=[1,19],$Ve=[1,20],$Vf=[1,21],$Vg=[1,22],$Vh=[1,23],$Vi=[1,25],$Vj=[1,26],$Vk=[1,27],$Vl=[1,28],$Vm=[1,29],$Vn=[1,30],$Vo=[5,6,7,8,9,10,11,12,13,14,15,16,17,19,20,32,33,36],$Vp=[5,6,7,8,12,13,14,15,16,17,19,32,33,36],$Vq=[1,58],$Vr=[1,59],$Vs=[19,32,33,36],$Vt=[5,6,7,8,9,10,12,13,14,15,16,17,19,32,33,36],$Vu=[5,6,12,13,14,15,16,19,32,33,36];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"expressions":3,"e":4,"EOF":5,"=":6,"+":7,"-":8,"*":9,"/":10,"^":11,"<>":12,">":13,"<":14,">=":15,"<=":16,"&":17,"(":18,")":19,":":20,"IDENT":21,"SCOPE":22,"func":23,"array_literal":24,"TRUE":25,"FALSE":26,"STRING":27,"NUMBER":28,"%":29,"range":30,"param_list":31,",":32,";":33,"FUNC":34,"{":35,"}":36,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",6:"=",7:"+",8:"-",9:"*",10:"/",11:"^",12:"<>",13:">",14:"<",15:">=",16:"<=",17:"&",18:"(",19:")",20:":",21:"IDENT",22:"SCOPE",25:"TRUE",26:"FALSE",27:"STRING",28:"NUMBER",29:"%",32:",",33:";",34:"FUNC",35:"{",36:"}"},
productions_: [0,[3,2],[3,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,2],[4,3],[4,2],[4,3],[4,3],[4,1],[4,2],[4,1],[4,1],[4,1],[4,1],[4,1],[4,2],[4,1],[30,3],[31,1],[31,3],[31,3],[23,4],[23,3],[24,3]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1: case 2:
 return $$[$0-1]; 
break;
case 3:
this.$ = { type: "operator", subtype: 'infix-add', operands:[$$[$0-2], $$[$0]]}; 
break;
case 4:
this.$ = { type: "operator", subtype: 'infix-subtract', operands:[$$[$0-2], $$[$0]]}; 
break;
case 5:
this.$ = { type: "operator", subtype: 'infix-multiply', operands:[$$[$0-2], $$[$0]]}; 
break;
case 6:
this.$ = { type: "operator", subtype: 'infix-divide', operands:[$$[$0-2], $$[$0]] }; 
break;
case 7:
this.$ = { type: "operator", subtype: 'infix-power', operands:[$$[$0-2], $$[$0]] }; 
break;
case 8:
this.$ = { type: "operator", subtype: 'infix-ne', operands:[$$[$0-2], $$[$0]] }; 
break;
case 9:
this.$ = { type: "operator", subtype: 'infix-eq', operands:[$$[$0-2], $$[$0]] }; 
break;
case 10:
this.$ = { type: "operator", subtype: 'infix-gt', operands:[$$[$0-2], $$[$0]] }; 
break;
case 11:
this.$ = { type: "operator", subtype: 'infix-lt', operands:[$$[$0-2], $$[$0]] }; 
break;
case 12:
this.$ = { type: "operator", subtype: 'infix-gte', operands:[$$[$0-2], $$[$0]] }; 
break;
case 13:
this.$ = { type: "operator", subtype: 'infix-lte', operands:[$$[$0-2], $$[$0]] }; 
break;
case 14:
this.$ = { type: "operator", subtype: 'prefix-plus', operands:[$$[$0]] }; 
break;
case 15:
this.$ = { type: "operator", subtype: 'infix-concat', operands:[$$[$0-2], $$[$0]] }; 
break;
case 16:
this.$ = { type: "operator", subtype: 'prefix-minus', operands:[$$[$0]] }; 
break;
case 17:
this.$ = { type: 'group', exp:$$[$0-1] }; 
break;
case 18:
this.$ = { type: 'range', subtype: 'local', topLeft:$$[$0-2], bottomRight:$$[$0] }; 
break;
case 19:
 this.$ = { type: 'variable', name:$$[$0] }; 
break;
case 20:
 this.$ = { type: 'variable', scope: $$[$0-1], name: $$[$0] }; 
break;
case 21: case 22:
 this.$ = $$[$0]; 
break;
case 23:
this.$ = { type: 'value', subtype: 'boolean', value: true }; 
break;
case 24:
this.$ = { type: 'value', subtype: 'boolean', value: false }; 
break;
case 25:
this.$ = { type: 'value', subtype: 'string', value:String(yytext)}; 
break;
case 26:
this.$ = { type: 'value', subtype: 'number', value:$$[$0-1]/100 }; 
break;
case 27:
this.$ = { type: 'value', subtype: 'number', value:Number(yytext) }; 
break;
case 29:
 this.$ = [$$[$0]]; 
break;
case 30:
 this.$ = $$[$0-2].concat([$$[$0]]); 
break;
case 31:
 this.$ = ($$[$0][0].subtype !== 'array') ? [{ type: 'value', subtype: 'array', items:$$[$0-2] }, { type: 'value', subtype: 'array', items:$$[$0] }] : [{ type: 'value', subtype: 'array', items:$$[$0-2] }].concat($$[$0]); 
break;
case 32:
 this.$ = { type: 'function', name: $$[$0-3], args:$$[$0-1] }; 
break;
case 33:
 this.$ = { type: 'function', name: $$[$0-2], args:[] }; 
break;
case 34:
 this.$ = { type: 'value', subtype: 'array', items:$$[$0-1] }; 
break;
}
},
table: [{3:1,4:2,6:[1,3],7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{1:[3]},{5:[1,17],6:$Vb,7:$Vc,8:$Vd,9:$Ve,10:$Vf,11:$Vg,12:$Vh,13:$Vi,14:$Vj,15:$Vk,16:$Vl,17:$Vm,20:$Vn},{4:31,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:32,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:33,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:34,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},o($Vo,[2,19]),{21:[1,35]},o($Vo,[2,21]),o($Vo,[2,22]),o($Vo,[2,23]),o($Vo,[2,24]),o($Vo,[2,25]),o($Vo,[2,27],{29:[1,36]}),{18:[1,37]},{4:39,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,31:38,34:$V9,35:$Va},{1:[2,1]},{4:40,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:41,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:42,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:43,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:44,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:45,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:46,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:47,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:48,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:49,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:50,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:51,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:52,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{5:[1,53],6:$Vb,7:$Vc,8:$Vd,9:$Ve,10:$Vf,11:$Vg,12:$Vh,13:$Vi,14:$Vj,15:$Vk,16:$Vl,17:$Vm,20:$Vn},o($Vp,[2,14],{9:$Ve,10:$Vf,11:$Vg,20:$Vn}),o($Vp,[2,16],{9:$Ve,10:$Vf,11:$Vg,20:$Vn}),{6:$Vb,7:$Vc,8:$Vd,9:$Ve,10:$Vf,11:$Vg,12:$Vh,13:$Vi,14:$Vj,15:$Vk,16:$Vl,17:$Vm,19:[1,54],20:$Vn},o($Vo,[2,20]),o($Vo,[2,26]),{4:39,7:$V0,8:$V1,18:$V2,19:[1,56],21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,31:55,34:$V9,35:$Va},{32:$Vq,33:$Vr,36:[1,57]},o($Vs,[2,29],{6:$Vb,7:$Vc,8:$Vd,9:$Ve,10:$Vf,11:$Vg,12:$Vh,13:$Vi,14:$Vj,15:$Vk,16:$Vl,17:$Vm,20:$Vn}),o($Vp,[2,3],{9:$Ve,10:$Vf,11:$Vg,20:$Vn}),o($Vp,[2,4],{9:$Ve,10:$Vf,11:$Vg,20:$Vn}),o($Vt,[2,5],{11:$Vg,20:$Vn}),o($Vt,[2,6],{11:$Vg,20:$Vn}),o([5,6,7,8,9,10,11,12,13,14,15,16,17,19,32,33,36],[2,7],{20:$Vn}),o($Vu,[2,8],{7:$Vc,8:$Vd,9:$Ve,10:$Vf,11:$Vg,17:$Vm,20:$Vn}),o($Vu,[2,9],{7:$Vc,8:$Vd,9:$Ve,10:$Vf,11:$Vg,17:$Vm,20:$Vn}),o($Vu,[2,10],{7:$Vc,8:$Vd,9:$Ve,10:$Vf,11:$Vg,17:$Vm,20:$Vn}),o($Vu,[2,11],{7:$Vc,8:$Vd,9:$Ve,10:$Vf,11:$Vg,17:$Vm,20:$Vn}),o($Vu,[2,12],{7:$Vc,8:$Vd,9:$Ve,10:$Vf,11:$Vg,17:$Vm,20:$Vn}),o($Vu,[2,13],{7:$Vc,8:$Vd,9:$Ve,10:$Vf,11:$Vg,17:$Vm,20:$Vn}),o([5,6,12,13,14,15,16,17,19,32,33,36],[2,15],{7:$Vc,8:$Vd,9:$Ve,10:$Vf,11:$Vg,20:$Vn}),o($Vo,[2,18]),{1:[2,2]},o($Vo,[2,17]),{19:[1,60],32:$Vq,33:$Vr},o($Vo,[2,33]),o($Vo,[2,34]),{4:61,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,34:$V9,35:$Va},{4:39,7:$V0,8:$V1,18:$V2,21:$V3,22:$V4,23:9,24:10,25:$V5,26:$V6,27:$V7,28:$V8,31:62,34:$V9,35:$Va},o($Vo,[2,32]),o($Vs,[2,30],{6:$Vb,7:$Vc,8:$Vd,9:$Ve,10:$Vf,11:$Vg,12:$Vh,13:$Vi,14:$Vj,15:$Vk,16:$Vl,17:$Vm,20:$Vn}),o([19,36],[2,31],{32:$Vq,33:$Vr})],
defaultActions: {17:[2,1],53:[2,2]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        function _parseError (msg, hash) {
            this.message = msg;
            this.hash = hash;
        }
        _parseError.prototype = Error;

        throw new _parseError(str, hash);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:/* skip whitespace */
break;
case 1:return 28
break;
case 2:return 25
break;
case 3:return 26
break;
case 4:return 25
break;
case 5:return 26
break;
case 6:return 25
break;
case 7:return 26
break;
case 8:return 9
break;
case 9:return 10
break;
case 10:return 8
break;
case 11:return 7
break;
case 12:return 17
break;
case 13:return 11
break;
case 14:return 18
break;
case 15:return 19
break;
case 16:return ">="
break;
case 17:return "<="
break;
case 18:return "<>"
break;
case 19:return "="
break;
case 20:return ">"
break;
case 21:return "<"
break;
case 22:return "{"
break;
case 23:return "}"
break;
case 24:return "!"
break;
case 25:return ","
break;
case 26:return ":"
break;
case 27:return ";"
break;
case 28:return "%"
break;
case 29:return 34;
break;
case 30:return 34;
break;
case 31:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2).replace(/\"\"/g, "\""); return "STRING";
break;
case 32:yy_.yytext = yy_.yytext.substr(2,yy_.yyleng-3).replace(/\"\"/g, "\""); return "SCOPE";
break;
case 33:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-3).replace(/\"\"/g, "\""); return "SCOPE";
break;
case 34:yy_.yytext = yy_.yytext.slice(0, -1); return "SCOPE"
break;
case 35:yy_.yytext = yy_.yytext.slice(1, -1); return "SCOPE"
break;
case 36:return 21
break;
case 37:return 5
break;
case 38:return 'INVALID'
break;
}
},
rules: [/^(?:\s+)/,/^(?:[0-9]+(\.[0-9]+)?\b)/,/^(?:TRUE\b)/,/^(?:FALSE\b)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:True\b)/,/^(?:False\b)/,/^(?:\*)/,/^(?:\/)/,/^(?:-)/,/^(?:\+)/,/^(?:&)/,/^(?:\^)/,/^(?:\()/,/^(?:\))/,/^(?:>=)/,/^(?:<=)/,/^(?:<>)/,/^(?:=)/,/^(?:>)/,/^(?:<)/,/^(?:\{)/,/^(?:\})/,/^(?:!)/,/^(?:,)/,/^(?::)/,/^(?:;)/,/^(?:%)/,/^(?:[A-Za-z](?=[(]))/,/^(?:[A-Za-z][A-Za-z0-9\.]+(?=[(]))/,/^(?:"(?:""|[^"])*")/,/^(?:\$'(?:''|[^'])*'!)/,/^(?:'(?:''|[^'])*'!)/,/^(?:[a-zA-Z]([a-zA-Z0-9_.$]+)?!)/,/^(?:\$([a-zA-Z])([a-zA-Z0-9_.$]+)?!)/,/^(?:([\[\]a-zA-Z0-9_.$^@\(]+))/,/^(?:$)/,/^(?:.)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();

function parse () { return parser.parse.apply(parser, arguments); };

var compiledNumber = 0;

function compile(exp) {
  var ast = exp,
      jsCode,
      functionCode,
      f,
      suppress = false,
      precedents = [],
      requires = [],
      namespace='funcs.';

  // convert to AST when string provided
  if (typeof ast === 'string') {
    ast = parse(exp);
  }

  function wrapString(s) {
    if (s[0] == "'" && s[s.length-1] === "'") {
      return s;
    }
    return '\'' + s + '\'';
  }

  function printFuncs(items) {
    return map( items, function(n){
      return 'function() { return (' + compiler( n ) + ') }';
    }).join(', ');
  }

  function printItems(items) {
    return map( items, function(n){
      return compiler( n );
    }).join(', ');
  }

  // define a compiler function to handle recurse the AST.
  function compiler( node ) {

    let lhs, rhs;

    // The node is expected to be either an operator, function or a value.
    switch(node.type) {
      case 'operator':
        switch(node.subtype) {
          case 'prefix-plus':
            return namespace + "numbervalue(" + printItems(node.operands) + ")";
          case 'prefix-minus':
            return "-" + namespace + "numbervalue(" + printItems(node.operands) + ")";
          case 'infix-add':
            requires.push('add');
            return namespace + "add(" + printItems(node.operands) + ")";
          case 'infix-subtract':
            requires.push('subtract');
            return (namespace + "subtract(" + printItems(node.operands) + ")");
          case 'infix-multiply':
            requires.push('multiply');
            return (namespace + "multiply(" + printItems(node.operands) + ")");
          case 'infix-divide':
            requires.push('divide');
            return (namespace + "divide(" + printItems(node.operands) + ")");
          case 'infix-power':
            requires.push('power');
            return (namespace + 'power(' + printItems(node.operands) + ')');
          case 'infix-concat':
            requires.push('concatenate');
            return namespace + "concatenate(" + printItems(node.operands) + ")";
          case 'infix-eq':
            requires.push('eq');
            return (namespace + "eq(" + printItems(node.operands) + ")");
          case 'infix-ne':
            requires.push('ne');
            return (namespace + "ne(" + printItems(node.operands) + ")");
          case 'infix-gt':
            requires.push('gt');
            return (namespace + "gt(" + printItems(node.operands) + ")");
          case 'infix-gte':
            requires.push('gte');
            return (namespace + "gte(" + printItems(node.operands) + ")");
          case 'infix-lt':
            requires.push('lt');
            return (namespace + "lt(" + printItems(node.operands) + ")");
          case 'infix-lte':
            requires.push('lte');
            return (namespace + "lte(" + printItems(node.operands) + ")");
        }
        throw TypeException("Unknown operator: " + node.subtype);
      case 'group':
        return ('(' +  compiler( node.exp ) + ')');
      case 'function':
      requires.push(node.name.toLowerCase() === 'if' ? 'branch' : node.name.toLowerCase());
      switch(node.name.toLowerCase()) {
        case 'if':
        return (namespace + 'branch( ' + printFuncs(node.args) + ' )');
        case 'and':
        case 'or':
        return (namespace + node.name.toLowerCase() + '( ' + printFuncs(node.args) + ' )');
        default:
        return (namespace + node.name.toLowerCase() + '( ' + printItems(node.args) + ' )');
      }
      case 'cell':
        if (typeof precedents !== "undefined" && !suppress) { precedents.push(node); }

        return 'context.get(\"' + node.addr + '\")';

      case 'range':

        if (typeof precedents !== "undefined") { precedents.push(node); suppress = true; }
        lhs = compiler(node.topLeft);
        rhs = compiler(node.bottomRight);
        suppress = false;

        // anonymous functions are the perfect solution for dynamic ranges but was not immediately obvious to me
        if ( node.topLeft.type === "function" ) {
          lhs = "function() { return (" + lhs + "); }"
        }

        if ( node.bottomRight.type === "function" ) {
          rhs = "function() { return (" + rhs + "); }"
        }

        requires.push('ref');
        return ('this.ref( ' + lhs + ', ' + rhs + ' )' );

      case 'variable':
        if (precedents && !suppress) { precedents.push(node); }
        if (  node.scope) {
          return 'context.get(\"' + node.name + '\", \"' + node.scope + '\")';
        }
        return 'context.get(\"' + node.name + '\")';
      case 'value':
        switch (node.subtype) {
          case 'array':
            return ('[' + printItems(node.items) + ']');
          case 'string':
            return "'" + node.value.replace(/'/g, "''") + "'";

          default:
            return node.value;
        }
    }
  }

  var id = compiledNumber++;

  var compiled = compiler(ast);

  f = new Function('context', 'funcs',
`/* formula: ${exp} */
return (${compiled});
//# sourceURL=formula_${id}
`
  );

  f.id = id;
  f.exp = exp;
  f.ast = ast;
  f.code = compiled;
  f.precedents = precedents;
  f.requires = requires;

  return f

}

// Copyright 2015 JC Fisher

// ISFUNCTION returns true when `value` is a function.
function isfunction(value) {
    return value && Object.prototype.toString.call(value) == '[object Function]';
};

// Ponyfill or Object.assign
function assign(initial, ...list) {
  let func = Object.assign || assign;
  return func(initial, ...list)
}

// Execute a formula expression
function run(exp, params={}) {
  var compiled = isfunction(exp) ? exp : compile(exp);

  let funcs = functions
  let locals = assign({}, params)

  // Default get for plain object.
  if (locals.get !== 'function') {
    locals.get = (name, scope) => {
      if (typeof scope !== 'undefined') return locals[scope] ? locals[scope][name] : undefined
      return locals[name]
    }
  }

  return compiled(locals, funcs)
}

// Copyright 2015 JC Fisher

// ISNA returns true when the value is `#NA!`
function isnan(value) {
  if (Number.isNaN) return Number.isNaN(value);
  return typeof value === 'number' && isNaN(value);
}

// Returns true when the value is a falsy value.
// https://developer.mozilla.org/en-US/docs/Glossary/Falsy
function isfalsy(value) {
    return (
      value === false ||
      value === 0 ||
      value === '' ||
      typeof value === 'undefined' ||
      value === null ||
      isnan(value)
    )
};

// Returns true when the value is not falsey
// https://developer.mozilla.org/en-US/docs/Glossary/Truthy
function istruthy(value) {
    return !isfalsy(value)
};

// Copyright 2015 JC Fisher

// reduce an array to a value
function reduce(arr, func, ...rest) {
  return arr.reduce(func, ...rest)
}

// branch( test, result_if_true, [test2, result_if_true,] false_result )
function branch(...cases) {

  var resolved = false

  // Reduce all cases into a value.
  return reduce( cases, function(acc, item, index) {
    let val;

    // Return previously resolved result
    if (resolved === true) return acc

    // Handle last item
    if ( index === cases.length - 1 ) {
      // There is no last item.
      if (index % 2 === 1) return;

      // return the last item
      return isfunction(item) ? item() : item;
    }

    // Check if condition is true
    if (index % 2 === 0 && (
        (isfunction(item) && istruthy(item()) ) ||
        (!isfunction(item) && istruthy(item)))) {
      resolved = true
      val = cases[index+1]
      return isfunction(val) ? val() : val;
    }

    return acc;

  }, undefined)

}

// Copyright 2015 JC Fisher

// List of errors in the spreadsheet system

function FFError(message, name) {
    this.name = name || "NotImplementedError";
    this.message = (message || "");
}

FFError.prototype = Error.prototype;
FFError.prototype.toString = function() { return this.message }

let nil = new FFError('#NULL!', "Null reference");
let div0 = new FFError('#DIV/0!', "Divide by zero");
let value = new FFError('#VALUE!', "Invalid value");
let ref = new FFError('#REF!', "Invalid reference");
let name = new FFError('#NAME?', "Invalid name");
let num = new FFError('#NUM!', "Invalid number");
let na = new FFError('#N/A!', "Not applicable");
let error$1 = new FFError('#ERROR!', "Error");
let data = new FFError('#GETTING_DATA!', "Error getting data");
let missing = new FFError('#MISSING!', "Missing");
let unknown = new FFError('#UNKNOWN!', "Unknown error");
var error$2 = {
  nil,
  div0,
  value,
  ref,
  name,
  num,
  na,
  error: error$1,
  data,
  missing,
  unknown
}

// CHOOSE accepts an index and a list of items. It returns the item that corresponds to the index.
function choose(index, ...items) {

  // Return `#NA!` if index or items are not provided.
  if (!index || items.length === 0) {
    return error$2.na;
  }

  // Return `#VALUE!` if index is less than 1 or greater than 254.
  if (index < 1 || index > 254) {
    return error$2.value;
  }

  // Return `#VALUE!` if number of items is less than index.
  if (items.length < index) {
    return error$2.value;
  }

  // Return the item.
  return items[index-1];
}

// ISERR returns true when the value is an error (except `#NA!`) or when then
// value is a number which is NaN or [-]Infinity.
function iserr(value) {
  return (
    (
      value &&
      value !== error$2.na &&
      value.constructor && value.constructor.name === 'Error'
    ) || (
      typeof value === 'number' && (
        isnan(value) || !isFinite(value)
      )
    )
  );
}

// ISERROR returns true when the value is an error.
function iserror(value) {
    return iserr(value) || value === error$2.na;
}

// AND reduces list of truthy values into true or false value
function and(...criteria) {

  // Reduce criteria into boolean value.
  return reduce(
    criteria,
    (acc, item) => {

      // Once `false` or #error! is found always return previously value
      if (acc === false || iserror(acc)) return acc

      // find the value if a literal or deferred value
      let val = isfunction(item) ? item() : item

      // return `#VALUE!` if not true, false, 1 or 0
      if (val !== true && val !== false && val !== 1 && val !== 0) {
        return error$2.value
      }

      // Return true when value is true or 1
      return val === true || val === 1;
    })
}

// OR returns true when any of the criter is true or 1.
function or(...criteria) {
  return reduce( criteria, (acc, item) => {
    if (acc === true) return true;
    let value = isfunction(item) ? item() : item;
    return value === true || value === 1;
  }, false)
}

// NOT negates a `value`
function not(value) {
  return (value !== true && value !== false && value !== 1 && value !== 0) ? 
  error$2.value :
  !value
}

// Copyright 2015 JC Fisher

// EQ compares two values and returns a boolean value.
function eq(a,b) {
  // String comparisions are case-insensitive
  if (typeof a === "string" && typeof b === "string") {
    return a.toLowerCase() === b.toLowerCase()
  } else {
    return a === b;
  }
}

// NE returns true when a is not equal to b.
function ne(a,b) {
  return !eq(a, b)
}

// Copyright 2015 JC Fisher

// ISARRAY returns true when the value is an aray.
function isarray(value) {
  return Object.prototype.toString.call( value ) === '[object Array]'
}

// Copyright 2015 JC Fisher

// ISBLANK returns true when the value is undefined or null.
function isblank(value) {
    return typeof value === 'undefined' || value === null;
};

// ISREF returns true when the value is a reference.
function isref(value) {
  if (!value) return false
  return value._isref === true
}

function gt(a,b) {
  if ( isref(a) && isref(b) ) {
    return error$2.na;
  } else if ( isarray(a) && isarray(b) ) {
    return error$2.na;
  } else if ( isref(a) || isarray(a) ) {
    return map( a, (d) => d > b );
  } else if ( isref(b) || isarray(b) ) {
    return map( a, (d) => d > a );
  } else {
    return a > b;
  }
}

function gte(a,b) {
  if ( isref(a) && isref(b) ) {
    return error.na;
  } else if ( isarray(a) && isarray(b) ) {
    return error.na;
  } else if ( isref(a) || isarray(a) ) {
    return map( a, (d) => d >= b );
  } else if ( isref(b) || isarray(b) ) {
    return map( a, (d) => d >= a );
  } else {
    return a >= b;
  }
}

// LT compares two values and returns true when a is less than b.
function lt(a,b) {
  if ( isref(a) && isref(b) ) {
    return error.na;
  } else if ( isarray(a) && isarray(b) ) {
    return error.na;
  } else if ( isref(a) || isarray(a) ) {
    return map( a, (d) => d < b );
  } else if ( isref(b) || isarray(b) ) {
    return map( a, (d) => d < a );
  } else {
    return a < b;
  }
}

// LT compares two values and returns true when a is less than or equal to b.
function lte(a,b) {
  if ( isref(a) && isref(b) ) {
    return error.na;
  } else if ( isarray(a) && isarray(b) ) {
    return error.na;
  } else if ( isref(a) || isarray(a) ) {
    return map( a, (d) => d <= b );
  } else if ( isref(b) || isarray(b) ) {
    return map( a, (d) => d <= a );
  } else {
    return a <= b;
  }
}

// IFBLANK return the `value` if non-blank, otherwise it returns `value_if_blank`.
function ifblank(value, value_if_blank) {
    return isblank(value) ? value_if_blank : value;
}

// Copyright 2015 JC Fisher

// ISTEXT returns true when the value is a string.
function istext(value) {
    return 'string' === typeof(value);
};

// ISEMPTY returns true when the value is blank, is an empty array or when it
// is an empty string.
function isempty(value) {
    return (
      isblank(value) ||
      isarray(value) && value.length === 0 ||
      istext(value) && value === ''
    );
};

// IFBLANK return the `value` if empty, otherwise it returns `value_if_empty`.
function ifempty(value, value_if_empty) {
    return isempty(value) ? value_if_empty : value;
}

// IFBLANK return the `value` if error, otherwise it returns `value_if_error`.
function iferror(value, value_if_error=null) {
    return iserror(value) ? value_if_error : value;
}

// IFBLANK return the `value` if `#NA!`, otherwise it returns `value_if_na`.
function ifna(value, value_if_na) {
    return value === error$2.na ? value_if_na : value;
}

// Copyright 2015 JC Fisher

// returns true if true or false
function isboolean(val) {
    return val === true || val === false
};

// Copyright 2015 JC Fisher

// ISDATE returns true when the `value` is a JavaScript date object.
function isdate(value) {
    return value && Object.prototype.toString.call(value) == '[object Date]';
};

// Copyright 2015 JC Fisher

// ISEMAIL returns true when the `value` matches the regex.
function isemail(value) {
  // credit to http://stackoverflow.com/questions/46155/validate-email-address-in-javascript
  var re = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return re.test(value);
};

// Copyright 2015 JC Fisher

// ISEVEN returns true when the value is even.
function iseven(value) {
    return !(Math.floor(Math.abs(value)) & 1);
}

// Copyright 2015 JC Fisher

// Shared constants
let d1900 = new Date(1900, 0, 1);
let JulianOffset = 2415019;
let SecondsInMinute = 60;
let SecondsInHour = 3600;
let SecondsInDay = 86400;
let MilliSecondsInDay = 86400000;
let AllowedDates = {H: "h]", M: "m]", MM: "mm]", S: "s]", SS: "ss]"};
let DayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
let DayNames3 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
let MonthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
let MonthNames3 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
let AM = "AM";
let AM1 = "A";
let PM = "PM";
let PM1 = "P";
let τ = 6.28318530717958;
let MaxCols = 16384;
let SeparatorChar = ",";
let DecimalChar = ".";
let DefaultCurrency = "$";
let AllowedColors = {
    BLACK: "#000000",
    BLUE: "#0000FF",
    CYAN: "#00FFFF",
    GREEN: "#00FF00",
    MAGENTA: "#FF00FF",
    RED: "#FF0000",
    WHITE: "#FFFFFF",
    YELLOW: "#FFFF00"
  };

// PARSEDATE converts a value into a Date object.
function parsedate(val) {

  /* *******************
  Extracted from Social Calc

  convert_date_julian_to_gregorian(juliandate)

  ymd->{}
  .year
  .month
  .day

  From: http://aa.usno.navy.mil/faq/docs/JD_Formula.html
  Uses: Fliegel, H. F. and van Flandern, T. C. (1968). Communications of the ACM, Vol. 11, No. 10 (October, 1968).
  Translated from the FORTRAN

  ************************* */
  function convert_date_julian_to_gregorian(juliandate) {

    var L, N, I, J, K;

    L = juliandate+68569;
    N = Math.floor(4*L/146097);
    L = L-Math.floor((146097*N+3)/4);
    I = Math.floor(4000*(L+1)/1461001);
    L = L-Math.floor(1461*I/4)+31;
    J = Math.floor(80*L/2447);
    K = L-Math.floor(2447*J/80);
    L = Math.floor(J/11);
    J = J+2-12*L;
    I = 100*(N-49)+I+L;

    return new Date(I, J-1, K);

  }

  if (val instanceof Error) {
    return val;
  } else if (typeof val === 'number') {
    // val is assumed to be serial number.
    return convert_date_julian_to_gregorian( Math.floor(val+JulianOffset) );
  } else if (typeof val === 'string') {
    var timestamp=Date.parse(val)
    if (isnan(timestamp))
    {
      return error$2.value;
    }
    return new Date(timestamp);
  }

  return error$2.value;

}

function isleapyear(val) {
    var date = parsedate(val);
    var year = date.getFullYear();
    return (((year % 4 === 0) && (year % 100 !== 0)) ||
            (year % 400 === 0));
}

// ISNA returns true when the value is `#NA!`
function isna(value) {
  return value === error$2.na;
}

// Copyright 2015 JC Fisher

// Returns true when the value is a finite number.
function isnumber(value) {
    return typeof(value) === 'number' && !isNaN(value) && isFinite(value);
}

// Copyright 2015 JC Fisher

// ISODD returns true when the value is odd.
function isodd(value) {
  return !!(Math.floor(Math.abs(value)) & 1);
}

function isoweeknum(date) {
    date = parsedate(date);

    if (date instanceof Error) {
        return date;
    }

    date.setHours(0, 0, 0);
    date.setDate(date.getDate() + 4 - (date.getDay() || 7));
    var yearStart = new Date(date.getFullYear(), 0, 1);
    return Math.ceil((((date - yearStart) / MilliSecondsInDay) + 1) / 7);
};

// Copyright 2015 JC Fisher

// ISURL returns true when the value matches the regex for a uniform resource locator.
function isurl(str){
  // credit: http://stackoverflow.com/questions/5717093/check-if-a-javascript-string-is-an-url
  var pattern = new RegExp('^(https?:\\/\\/)?'+ // protocol
  '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.?)+[a-z]{2,}|'+ // domain name
  '((\\d{1,3}\\.){3}\\d{1,3}))'+ // OR ip (v4) address
  '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*'+ // port and path
  '(\\?[;&a-z\\d%_.~+=-]*)?'+ // query string
  '(\\#[-a-z\\d_]*)?$','i'); // fragment locator
  return pattern.test(str);
}

// Returns true when the value is a whole number
function iswholenumber(value) {
    return isnumber(value) && (value % 1 === 0);
}

// FLATTEN converts a nested array into a flattened array. It only supports one
// level of nesting.
function flatten(ref){

  if (!isarray(ref)) {
    return error$2.value;
  }

  return reduce( ref, function(a, b) {
    return a.concat(b);
  }, []);
}

// XOR computes the exclusive or for a given set of `values`.
function xor(...values) {
    return !!( reduce( flatten(values), (a,b) => {
      if (b) {
        return a+1
      }
      return a
    }, 0) & 1)
}

// ADD calculates the sum of two numbers.
function add(...values) {

  // Return `#NA!` if 2 arguments are not provided.
  if (values.length !== 2) {
    return error$2.na;
  }

  // decompose values into a and b.
  var [a, b] = values

  // Return `#VALUE!` if either a or b is not a number.
  if (!isnumber(a) || !isnumber(b)) {
    return error$2.value
  }

  // Return the sum.
  return a + b
}

// SUBTRACT calculates the difference of two numbers.
function subtract(...values) {

  // Return `#NA!` if 2 arguments are not provided.
  if (values.length !== 2) {
    return error$2.na;
  }

  // decompose values into a and b.
  var [a, b] = values

  // Return `#VALUE!` if either a or b is not a number.
  if (!isnumber(a) || !isnumber(b)) {
    return error$2.value
  }

  // Return the difference.
  return a - b
}

// MULTIPLY calculates the product of two numbers.
function multiply(...values) {

  // Return `#NA!` if 2 arguments are not provided.
  if (values.length !== 2) {
    return error$2.na;
  }

  // decompose values into a and b.
  var [a, b] = values

  // Return `#VALUE!` if either a or b is not a number.
  if (!isnumber(a) || !isnumber(b)) {
    return error$2.value
  }

  // Return the product
  return a * b
}

// DIVIDE calculates the product of two numbers.
function divide(...values) {

  // Return `#NA!` if 2 arguments are not provided.
  if (values.length !== 2) {
    return error$2.na;
  }

  // decompose values into a and b.
  var [a, b] = values

  // You cannot divide a number by 0.
  if (b === 0) {
    return error$2.div0
  }

  // Return `#VALUE!` if either a or b is not a number.
  if (!isnumber(a) || !isnumber(b)) {
    return error$2.value
  }

  // Return the product
  return a / b
}

// ABS computes absolute value of a number
function abs(value) {

  // Return `#VALUE!` if not number
  if (!isnumber(value)) {
    return error$2.value;
  }

  // Use built-in Math.abs
  return Math.abs(value);
}

// ACOS computes the inverse cosine of a number
function acos(value) {

  // Return `#VALUE!` if not number
  if (!isnumber(value)) {
    return error$2.value;
  }

  // Use built-in Math.acos
  return Math.acos(value);

}

// COS returns the cosine of a value.
function cos(value) {

  // Return `#VALUE!` when value is not a number.
  if (!isnumber(value)) {
    return error$2.value;
  }

  return Math.cos(value);

}

// PI returns half the universal circle constant
function pi() {
  return τ / 2;
}

// POWER computes the power of a value and nth degree.
function power(...values) {

  // Return `#NA!` if 2 arguments are not provided.
  if (values.length !== 2) {
    return error$2.na;
  }

  // decompose values into a and b.
  var [val, nth] = values

  // Return `#VALUE!` if either a or b is not a number.
  if (!isnumber(val) || !isnumber(nth)) {
    return error$2.value
  }

  // Compute the power of val to the nth.
  return Math.pow(val, nth);
}

// Copyright 2015 JC Fisher

// CONVERT a number to a fixed precision.
function round(number, precision) {
  return +number.toFixed(precision);
}

// Copyright 2015 JC Fisher

// ROUNDUP converts a number to a fixed precision by rounding up.
function roundup(number, precision) {
  var factors = [1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000];
  var factor = factors[precision];
  if (number > 0) {
    return Math.ceil(number * factor) / factor;
  } else {
    return Math.floor(number * factor) / factor;
  }
}

// SIN calculates the sinine of a value.
function sin(value) {

  if (!isnumber(value)) {
    return error$2.value;
  }

  return Math.sin(value);

}

// TAN computes the tagent of a value.
function tan(value) {

  if (!isnumber(value)) {
    return error$2.value;
  }

  return Math.tan(value);

}

// TAU returns the universal circle constant
function tau() {
  return τ;
}

// Copyright 2015 JC Fisher

// remove decimal part of number
function trunc(val) {
  return val|0;
}

// Copyright 2015 JC Fisher

// CHAR convert number into character (e.g 65 => 'A')
function char(number) {
  return String.fromCharCode(number);
}

// CODE accepts text and optionally index (default 1) returning the character code.
function code(text='', index=1) {
  if (index < 1) return error$2.na
  if (text.length < index) return error$2.value
  return text.charCodeAt(index-1);
}

// CONCATENATE reduces a list of values into a single string.
function concatenate(...values) {
  // Combine into a single string value
  return reduce( values, (acc, item) => `${acc}${item}`, '' )
}

// Exact compares two values and only returns true if they meet strict equivalence.
function exact(a, b) {
  return a === b
}

// FIND searches for text within a string
function find(find_text, within_text='', position=1) {

  // Find the position of the text
  position = within_text.indexOf(find_text, position - 1)

  // If found return the position as base 1.
  return position === -1 ? error$2.value : position+1
}

// combine a array of strings/numbers into a single string
function join(list, delim=', ') {

  // all values must be string or number
  if (list.some(d => typeof d !== 'string' && typeof d !== 'number')) {
    return error$2.value
  }

  // defer to JS implementation
  return list.join(delim)
}

// SERIAL convert a date object into a serial number.
function serial(date) {
  // Credit: https://github.com/sutoiku/formula.js/
  if (!isdate(date)) { return error$2.na }
  var diff = Math.ceil((date - d1900) / MilliSecondsInDay)
  return diff + ( diff > 59 ? 2 : 1)
}

// N converts a `value` to a number. It supports numbers, true, false and dates.
function n(value) {

  // Pass numbers and errors back out.
  if (isnumber(value) || iserror(value)) {
    return value;
  }

  // Convert dates to serial number.
  if (value instanceof Date) {
    return serial(value);
  }

  // Convert true to 1
  if (value === true) {
    return 1;
  }

  // Convert false to 0
  if (value === false) {
    return 0;
  }

  // Return 0 in all other cases.
  return 0;

}

function left(text, number) {

  if (isblank(text)) {
    return ''
  }

  if (!n(+number)) {
    return text
  }

  return text.substring( 0, number )

}

// LEN returns the size of a string or array.
function len(text) {
  if (arguments.length === 0) {
    return error$2.error;
  }

  if (typeof text === 'string') {
    return text.length;
  }

  if (text.length) {
    return text.length;
  }

  return error$2.value;
};

// LOWER converts `value` to lower case
function lower(value) {
  if (!istext(value)) return error$2.value
  return value.toLowerCase()
}

// Copyright 2015 JC Fisher

// SPLIT `text` given a `delimiter`.
function split(text, delimiter) {
  return text.split(delimiter)
}

// Convert a text value into a number value.
function numbervalue(text, decimal_separator, group_separator)  {
  decimal_separator = decimal_separator || '.'
  group_separator = group_separator || ','

  // Return error when text is error
  if (iserror(text)) {
    return text
  }

  // Return `#VALUE!` when text is empty
  if (isempty(text)) {
    return error$2.value
  }

  // Return the value when it is already a number.
  if (isnumber(text)) {
    return text
  }

  var foundDecimal = false,
  len = text.length-1

  if (text.length === 1) {
    if ( code( text, 0 ) < 48 ||  code( text, 0 ) > 57 ) {
      return error$2.value
    }
    return +text
  }

  return reduce( split(text, ''), (acc, item, index) => {
    if (acc === error$2.value) {
      return error$2.value;
    } else if (len === index) {
      if (item === '%') {
        return +acc / 100
      }
      return +acc.concat(item)
    } else if (item === decimal_separator) {
      if (foundDecimal) return error$2.value;
      foundDecimal = true
      return acc.concat('.')
    } else if( item === group_separator ) {
      return acc
    // check if between 0 and 9 ascii codes
    } else if (item.charCodeAt(0) < 48 ||  item.charCodeAt(0) > 57) {
      return error$2.value
    }

    return acc.concat(item);

  })
};

// PARSEBOOL converts a truthy value into a boolean value.
function parsebool(val) {

  if (val instanceof Error) {
    return val;
  } else if (typeof val === 'boolean') {
    return val;
  } else if (typeof val === 'number') {
    return val !== 0;
  } else if (typeof val === 'string') {
    var up = val.toUpperCase();
    if (up === 'TRUE' || up === 'FALSE') {
      return up === 'TRUE';
    }
  }

  return error$2.value;
}

// parse querystring into object
function parsequery(query='') {

  if (typeof query !== 'string') {
    return error$2.na;
  }

  if (query.length === 0) {
    return {}
  }

  return reduce(
    (query[0] === '?' ? query.substr(1) : query)
    .split('&'),
    (acc, item) => {
      var n = item.split('=');
      var key = decodeURIComponent(n[0]);
      var value = decodeURIComponent(n[1] || '');
      acc[key] = value;
      return acc
    }, {} )
}

// PROPER converts text into proper case.
function proper(text) {
    if (text === undefined || text.length === 0) {
        return error$2.value;
    }
    if (text === true) {
        text = 'TRUE';
    }
    if (text === false) {
        text = 'FALSE';
    }
    if (isnan(text) && typeof text === 'number') {
        return error$2.value;
    }
    if (typeof text === 'number') {
        text = '' + text;
    }

    return text.replace(/\w\S*/g, function(txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
}

// REPLACE returns a new string after replacing with `new_text`.
function replace(text, position, length, new_text) {

  if (iserror(position) || iserror(length) ||
  typeof text !== 'string' || typeof new_text !== 'string') {
    return error$2.value;
  }
  return text.substr(0, position - 1) + new_text + text.substr(position - 1 + length);
}

// RIGHT pulls a given number of character from the right side of `text`.
function right(text, number) {

  if (isblank(text)) {
    return ''
  }

  if (!n(+number)) {
    return text
  }

  return text.substring( text.length - number )

}

// Copyright 2015 JC Fisher

// REPT creates string by repeating text a given number of times.
function rept(text, number) {
  var r = '';
  for (var i = 0; i < number; i++) {
    r += text;
  }
  return r;
}

// SEARCH finds text using wildcards ?, *, ~?, and ~*.
function search(find_text, within_text, position) {
    if (!within_text) { return null; }
    position = (typeof position === 'undefined') ? 1 : position;

    // The SEARCH function translated the find_text into a regex.
    var find_exp = find_text
        .replace(/([^~])\?/g, '$1.')   // convert ? into .
        .replace(/([^~])\*/g, '$1.*')  // convert * into .*
        .replace(/([~])\?/g, '\\?')    // convert ~? into \?
        .replace(/([~])\*/g, '\\*');   // convert ~* into \*

    position = new RegExp(find_exp, "i").exec(within_text);

    if (position) { return position.index + 1 }
    return error$2.value;
}

// Copyright 2015 JC Fisher

// SUBSTITUTE `old_text` with `new_text` a given number of occurrences in `text`.
function substitute(text, old_text, new_text, occurrence) {
  if (!text || !old_text || !new_text) {
    return text;
  } else if (occurrence === undefined) {
    return text.replace(new RegExp(old_text, 'g'), new_text);
  } else {
    var index = 0;
    var i = 0;
    while (text.indexOf(old_text, index) > 0) {
      index = text.indexOf(old_text, index + 1);
      i++;
      if (i === occurrence) {
        return text.substring(0, index) + new_text + text.substring(index + old_text.length);
      }
    }
  }
}

// Copyright 2015 JC Fisher

// combine a array of strings/numbers into a single string
function keys(subject) {
  return Object.keys(subject)
}

// substituteAll is a lightweight "substitution tags" engine that implement a global substitute for multiple items.
//
// The key values in your locals object are replaced. Unlike other templating systems it doesn't specify characters that surround your tokens.
//
// The function does not encode HTML entities. Don't use this to generate HTML. There are plently of alternative like underscore.js that do that already.
//
// It is equivalent to:
// ```js
// locals = { '-first-': 'Joe', '-last-': 'Smith' }
// substitute( substitute("-first- -last", '-first-',  locals), '-last-', 'Smith', locals)
// ```
function substituteAll(content, locals, start='-', end=start) {
  if (!locals) return content;
  return reduce( keys(locals), (p, v) => substitute(p, `${start}${v}${end}`, locals[v]), content)
}

// Creates a new object where all of the keys are surrounded by
// start and end delimiters.
function surroundKeys(obj, start='-', end) {
  end = end || start
  return reduce( keys(obj), (p, v) => {
    p[`${start}${v}${end}`] = obj[v];
    return p;
  }, {})
}

let FormatNumber = {};

FormatNumber.format_definitions = {}; // Parsed formats are stored here globally

// Other constants

FormatNumber.commands = {
  copy: 1, color: 2, integer_placeholder: 3, fraction_placeholder: 4, decimal: 5,
  currency: 6, general:7, separator: 8, date: 9, comparison: 10, section: 11, style: 12
};


/* *******************

result = FormatNumber.formatNumberWithFormat = function(rawvalue, format_string, currency_char)

************************* */

FormatNumber.formatNumberWithFormat = function(rawvalue, format_string, currency_char) {

  var scfn = FormatNumber;

  var op, operandstr, fromend, cval, operandstrlc;
  var startval, estartval;
  var hrs, mins, secs, ehrs, emins, esecs, ampmstr, ymd;
  var minOK, mpos, mspos;
  var result='';
  var format;
  var section, gotcomparison, compop, compval, cpos, oppos;
  var sectioninfo;
  var i, decimalscale, scaledvalue, strvalue, strparts, integervalue, fractionvalue;
  var integerdigits2, integerpos, fractionpos, textcolor, textstyle, separatorchar, decimalchar;
  var value; // working copy to change sign, etc.

  rawvalue = rawvalue-0; // make sure a number
  value = rawvalue;
  if (!isFinite(value)) return 'NaN';

  var negativevalue = value < 0 ? 1 : 0; // determine sign, etc.
  if (negativevalue) value = -value;
  var zerovalue = value == 0 ? 1 : 0;

  currency_char = currency_char || DefaultCurrency;

  FormatNumber.parse_format_string(scfn.format_definitions, format_string); // make sure format is parsed
  format = scfn.format_definitions[format_string]; // Get format structure

  if (!format) throw 'Format not parsed error.';

  section = format.sectioninfo.length - 1; // get number of sections - 1

  // has comparisons - determine which section
  if (format.hascomparison) {
    section = 0; // set to which section we will use
    gotcomparison = 0; // this section has no comparison
    for (cpos=0; ;cpos++) { // scan for comparisons
      op = format.operators[cpos];
      operandstr = format.operands[cpos]; // get next operator and operand

      // at end with no match
      if (!op) {
        // if comparison but no match
        if (gotcomparison) {
          format_string = 'General'; // use default of General
          scfn.parse_format_string(scfn.format_definitions, format_string);
          format = scfn.format_definitions[format_string];
          section = 0;
        }
        break; // if no comparision, matches on this section
      }
      // end of section
      if (op == scfn.commands.section) {
        if (!gotcomparison) { // no comparison, so it's a match
          break;
        }
        gotcomparison = 0;
        section++; // check out next one
        continue;
      }
      // found a comparison - do we meet it?
      if (op == scfn.commands.comparison) {
        i=operandstr.indexOf(':');
        compop=operandstr.substring(0,i);
        compval=operandstr.substring(i+1)-0;
        if ((compop == '<' && rawvalue < compval) ||
        (compop == '<=' && rawvalue <= compval) ||
        (compop == '=' && rawvalue == compval) ||
        (compop == '<>' && rawvalue != compval) ||
        (compop == '>=' && rawvalue >= compval) ||
        (compop == '>' && rawvalue > compval)) {
          break;
        }
        gotcomparison = 1;
      }
    }
  }
  // more than one section (separated by ";")
  else if (section > 0) {
    // two sections
    if (section == 1) {
      if (negativevalue) {
        negativevalue = 0; // sign will provided by section, not automatically
        section = 1; // use second section for negative values
      }
      else {
        section = 0; // use first for all others
      }
    }
    // three sections
    else if (section == 2) {
      if (negativevalue) {
        negativevalue = 0; // sign will provided by section, not automatically
        section = 1; // use second section for negative values
      }
      else if (zerovalue) {
        section = 2; // use third section for zero values
      }
      else {
        section = 0; // use first for positive
      }
    }
  }

  sectioninfo = format.sectioninfo[section]; // look at values for our section

  if (sectioninfo.commas > 0) { // scale by thousands
    for (i=0; i<sectioninfo.commas; i++) {
      value /= 1000;
    }
  }
  if (sectioninfo.percent > 0) { // do percent scaling
    for (i=0; i<sectioninfo.percent; i++) {
      value *= 100;
    }
  }

  decimalscale = 1; // cut down to required number of decimal digits
  for (i=0; i<sectioninfo.fractiondigits; i++) {
    decimalscale *= 10;
  }
  scaledvalue = Math.floor(value * decimalscale + 0.5);
  scaledvalue = scaledvalue / decimalscale;

  if (typeof scaledvalue != 'number') return 'NaN';
  if (!isFinite(scaledvalue)) return 'NaN';

  strvalue = scaledvalue+''; // convert to string (Number.toFixed doesn't do all we need)

  //   strvalue = value.toFixed(sectioninfo.fractiondigits); // cut down to required number of decimal digits
  // and convert to string

  if (scaledvalue == 0 && (sectioninfo.fractiondigits || sectioninfo.integerdigits)) {
    negativevalue = 0; // no "-0" unless using multiple sections or General
  }

  // converted to scientific notation
  if (strvalue.indexOf('e')>=0) {
    return rawvalue+''; // Just return plain converted raw value
  }

  strparts=strvalue.match(/^\+{0,1}(\d*)(?:\.(\d*)){0,1}$/); // get integer and fraction parts
  if (!strparts) return 'NaN'; // if not a number
  integervalue = strparts[1];
  if (!integervalue || integervalue=='0') integervalue='';
  fractionvalue = strparts[2];
  if (!fractionvalue) fractionvalue = '';

  // there are date placeholders
  if (sectioninfo.hasdate) {
    // bad date
    if (rawvalue < 0) {
      return '??-???-?? ??:??:??';
    }
    startval = (rawvalue-Math.floor(rawvalue)) * SecondsInDay; // get date/time parts
    estartval = rawvalue * SecondsInDay; // do elapsed time version, too
    hrs = Math.floor(startval / SecondsInHour);
    ehrs = Math.floor(estartval / SecondsInHour);
    startval = startval - hrs * SecondsInHour;
    mins = Math.floor(startval / 60);
    emins = Math.floor(estartval / 60);
    secs = startval - mins * 60;
    decimalscale = 1; // round appropriately depending if there is ss.0
    for (i=0; i<sectioninfo.fractiondigits; i++) {
      decimalscale *= 10;
    }
    secs = Math.floor(secs * decimalscale + 0.5);
    secs = secs / decimalscale;
    esecs = Math.floor(estartval * decimalscale + 0.5);
    esecs = esecs / decimalscale;
    if (secs >= 60) { // handle round up into next second, minute, etc.
      secs = 0;
      mins++; emins++;
      if (mins >= 60) {
        mins = 0;
        hrs++; ehrs++;
        if (hrs >= 24) {
          hrs = 0;
          rawvalue++;
        }
      }
    }
    fractionvalue = (secs-Math.floor(secs))+''; // for "hh:mm:ss.000"
    fractionvalue = fractionvalue.substring(2); // skip "0."

    ymd = parsedate(rawvalue);
    ymd = {
      year: ymd.getFullYear(),
      month: ymd.getMonth() + 1,
      day: ymd.getDate()
    }

    minOK = 0; // says "m" can be minutes if true
    mspos = sectioninfo.sectionstart; // m scan position in ops
    for ( ; ; mspos++) { // scan for "m" and "mm" to see if any minutes fields, and am/pm
      op = format.operators[mspos];
      operandstr = format.operands[mspos]; // get next operator and operand
      if (!op) break; // don't go past end
      if (op==scfn.commands.section) break;
      if (op==scfn.commands.date) {
        if ((operandstr.toLowerCase()=='am/pm' || operandstr.toLowerCase()=='a/p') && !ampmstr) {
          if (hrs >= 12) {
            if (hrs > 12) hrs -= 12;
            ampmstr = operandstr.toLowerCase()=='a/p' ? PM1 : PM; // "P" : "PM";
          }
          else {
            if (hrs === 0) hrs = 12;
            ampmstr = operandstr.toLowerCase()=='a/p' ? AM1 : AM; // "A" : "AM";
          }
          if (operandstr.indexOf(ampmstr)<0)
          ampmstr = ampmstr.toLowerCase(); // have case match case in format
        }
        if (minOK && (operandstr=='m' || operandstr=='mm')) {
          format.operands[mspos] += 'in'; // turn into "min" or "mmin"
        }
        if (operandstr.charAt(0)=='h') {
          minOK = 1; // m following h or hh or [h] is minutes not months
        }
        else {
          minOK = 0;
        }
      }
      else if (op!=scfn.commands.copy) { // copying chars can be between h and m
        minOK = 0;
      }
    }
    minOK = 0;
    for (--mspos; ; mspos--) { // scan other way for s after m
      op = format.operators[mspos];
      operandstr = format.operands[mspos]; // get next operator and operand
      if (!op) break; // don't go past end
      if (op==scfn.commands.section) break;
      if (op==scfn.commands.date) {
        if (minOK && (operandstr=='m' || operandstr=='mm')) {
          format.operands[mspos] += 'in'; // turn into "min" or "mmin"
        }
        if (operandstr=='ss') {
          minOK = 1; // m before ss is minutes not months
        }
        else {
          minOK = 0;
        }
      }
      else if (op!=scfn.commands.copy) { // copying chars can be between ss and m
        minOK = 0;
      }
    }
  }

  integerdigits2 = 0; // init counters, etc.
  integerpos = 0;
  fractionpos = 0;
  textcolor = '';
  textstyle = '';
  separatorchar = SeparatorChar;
  if (separatorchar.indexOf(' ')>=0) separatorchar = separatorchar.replace(/ /g, ' ');
  decimalchar = DecimalChar;
  if (decimalchar.indexOf(' ')>=0) decimalchar = decimalchar.replace(/ /g, ' ');

  oppos = sectioninfo.sectionstart;

  while (op = format.operators[oppos]) { // execute format
    operandstr = format.operands[oppos++]; // get next operator and operand

    if (op == scfn.commands.copy) { // put char in result
      result += operandstr;
    }

    else if (op == scfn.commands.color) { // set color
      textcolor = operandstr;
    }

    else if (op == scfn.commands.style) { // set style
      textstyle = operandstr;
    }

    else if (op == scfn.commands.integer_placeholder) { // insert number part
      if (negativevalue) {
        result += '-';
        negativevalue = 0;
      }
      integerdigits2++;
      if (integerdigits2 == 1) { // first one
        if (integervalue.length > sectioninfo.integerdigits) { // see if integer wider than field
          for (;integerpos < (integervalue.length - sectioninfo.integerdigits); integerpos++) {
            result += integervalue.charAt(integerpos);
            if (sectioninfo.thousandssep) { // see if this is a separator position
              fromend = integervalue.length - integerpos - 1;
              if (fromend > 2 && fromend % 3 == 0) {
                result += separatorchar;
              }
            }
          }
        }
      }
      if (integervalue.length < sectioninfo.integerdigits
        && integerdigits2 <= sectioninfo.integerdigits - integervalue.length) { // field is wider than value
          if (operandstr == '0' || operandstr == '?') { // fill with appropriate characters
          result += operandstr == '0' ? '0' : ' ';
          if (sectioninfo.thousandssep) { // see if this is a separator position
            fromend = sectioninfo.integerdigits - integerdigits2;
            if (fromend > 2 && fromend % 3 == 0) {
              result += separatorchar;
            }
          }
        }
      }
      else { // normal integer digit - add it
        result += integervalue.charAt(integerpos);
        if (sectioninfo.thousandssep) { // see if this is a separator position
          fromend = integervalue.length - integerpos - 1;
          if (fromend > 2 && fromend % 3 == 0) {
            result += separatorchar;
          }
        }
        integerpos++;
      }
    }
    else if (op == scfn.commands.fraction_placeholder) { // add fraction part of number
      if (fractionpos >= fractionvalue.length) {
        if (operandstr == '0' || operandstr == '?') {
          result += operandstr == '0' ? '0' : ' ';
        }
      }
      else {
        result += fractionvalue.charAt(fractionpos);
      }
      fractionpos++;
    }

    else if (op == scfn.commands.decimal) { // decimal point
      if (negativevalue) {
        result += '-';
        negativevalue = 0;
      }
      result += decimalchar;
    }

    else if (op == scfn.commands.currency) { // currency symbol
      if (negativevalue) {
        result += '-';
        negativevalue = 0;
      }
      result += operandstr;
    }

    else if (op == scfn.commands.general) { // insert "General" conversion

      // *** Cut down number of significant digits to avoid floating point artifacts:

      if (value!=0) { // only if non-zero
        var factor = Math.floor(Math.LOG10E * Math.log(value)); // get integer magnitude as a power of 10
        factor = Math.pow(10, 13-factor); // turn into scaling factor
        value = Math.floor(factor * value + 0.5)/factor; // scale positive value, round, undo scaling
        if (!isFinite(value)) return 'NaN';
      }
      if (negativevalue) {
        result += '-';
      }
      strvalue = value+''; // convert original value to string
      if (strvalue.indexOf('e')>=0) { // converted to scientific notation
      result += strvalue;
      continue;
    }
    strparts=strvalue.match(/^\+{0,1}(\d*)(?:\.(\d*)){0,1}$/); // get integer and fraction parts
    integervalue = strparts[1];
    if (!integervalue || integervalue=='0') integervalue='';
    fractionvalue = strparts[2];
    if (!fractionvalue) fractionvalue = '';
    integerpos = 0;
    fractionpos = 0;
    if (integervalue.length) {
      for (;integerpos < integervalue.length; integerpos++) {
        result += integervalue.charAt(integerpos);
        if (sectioninfo.thousandssep) { // see if this is a separator position
          fromend = integervalue.length - integerpos - 1;
          if (fromend > 2 && fromend % 3 == 0) {
            result += separatorchar;
          }
        }
      }
    }
    else {
      result += '0';
    }
    if (fractionvalue.length) {
      result += decimalchar;
      for (;fractionpos < fractionvalue.length; fractionpos++) {
        result += fractionvalue.charAt(fractionpos);
      }
    }
  }
  else if (op==scfn.commands.date) { // date placeholder
    operandstrlc = operandstr.toLowerCase();
    if (operandstrlc=='y' || operandstrlc=='yy') {
      result += (ymd.year+'').substring(2);
    }
    else if (operandstrlc=='yyyy') {
      result += ymd.year+'';
    }
    else if (operandstrlc=='d') {
      result += ymd.day+'';
    }
    else if (operandstrlc=='dd') {
      cval = 1000 + ymd.day;
      result += (cval+'').substr(2);
    }
    else if (operandstrlc=='ddd') {
      cval = Math.floor(rawvalue+6) % 7;
      result += DayNames3[cval];
    }
    else if (operandstrlc=='dddd') {
      cval = Math.floor(rawvalue+6) % 7;
      result += DayNames[cval];
    }
    else if (operandstrlc=='m') {
      result += ymd.month+'';
    }
    else if (operandstrlc=='mm') {
      cval = 1000 + ymd.month;
      result += (cval+'').substr(2);
    }
    else if (operandstrlc=='mmm') {
      result += MonthNames3[ymd.month-1];
    }
    else if (operandstrlc=='mmmm') {
      result += MonthNames[ymd.month-1];
    }
    else if (operandstrlc=='mmmmm') {
      result += MonthNames[ymd.month-1].charAt(0);
    }
    else if (operandstrlc=='h') {
      result += hrs+'';
    }
    else if (operandstrlc=='h]') {
      result += ehrs+'';
    }
    else if (operandstrlc=='mmin') {
      cval = (1000 + mins)+'';
      result += cval.substr(2);
    }
    else if (operandstrlc=='mm]') {
      if (emins < 100) {
        cval = (1000 + emins)+'';
        result += cval.substr(2);
      }
      else {
        result += emins+'';
      }
    }
    else if (operandstrlc=='min') {
      result += mins+'';
    }
    else if (operandstrlc=='m]') {
      result += emins+'';
    }
    else if (operandstrlc=='hh') {
      cval = (1000 + hrs)+'';
      result += cval.substr(2);
    }
    else if (operandstrlc=='s') {
      cval = Math.floor(secs);
      result += cval+'';
    }
    else if (operandstrlc=='ss') {
      cval = (1000 + Math.floor(secs))+'';
      result += cval.substr(2);
    }
    else if (operandstrlc=='am/pm' || operandstrlc=='a/p') {
      result += ampmstr;
    }
    else if (operandstrlc=='ss]') {
      if (esecs < 100) {
        cval = (1000 + Math.floor(esecs))+'';
        result += cval.substr(2);
      }
      else {
        cval = Math.floor(esecs);
        result += cval+'';
      }
    }
  }
  else if (op == scfn.commands.section) {
    // end of section
    break;
  }

  else if (op == scfn.commands.comparison) {
    // ignore
    continue;
  }

  else {
    result += '!! Parse error.!!';
  }
}

if (textcolor) {
  result = '<span style="color:'+textcolor+';">'+result+'</span>';
}
if (textstyle) {
  result = '<span style="'+textstyle+';">'+result+'</span>';
}

//console.log(result)

return result;

};

/* *******************

FormatNumber.parse_format_string(format_defs, format_string)

Takes a format string (e.g., "#,##0.00_);(#,##0.00)") and fills in format_defs with the parsed info

format_defs
["#,##0.0"]->{} - elements in the hash are one hash for each format
.operators->[] - array of operators from parsing the format string (each a number)
.operands->[] - array of corresponding operators (each usually a string)
.sectioninfo->[] - one hash for each section of the format
.start
.integerdigits
.fractiondigits
.commas
.percent
.thousandssep
.hasdates
.hascomparison - true if any section has [<100], etc.

************************* */

FormatNumber.parse_format_string = function(format_defs, format_string) {

  var scfn = FormatNumber;

  var format, section, sectioninfo;
  var integerpart = 1; // start out in integer part
  var lastwasinteger; // last char was an integer placeholder
  var lastwasslash; // last char was a backslash - escaping following character
  var lastwasasterisk; // repeat next char
  var lastwasunderscore; // last char was _ which picks up following char for width
  var inquote, quotestr; // processing a quoted string
  var inbracket, bracketstr, bracketdata; // processing a bracketed string
  var ingeneral, gpos; // checks for characters "General"
  var ampmstr, part; // checks for characters "A/P" and "AM/PM"
  var indate; // keeps track of date/time placeholders
  var chpos; // character position being looked at
  var ch; // character being looked at

  if (format_defs[format_string]) return; // already defined - nothing to do

  format = {operators: [], operands: [], sectioninfo: [{}]}; // create info structure for this format
  format_defs[format_string] = format; // add to other format definitions

  section = 0; // start with section 0
  sectioninfo = format.sectioninfo[section]; // get reference to info for current section
  sectioninfo.sectionstart = 0; // position in operands that starts this section
  sectioninfo.integerdigits = 0; // number of integer-part placeholders
  sectioninfo.fractiondigits = 0; // fraction placeholders
  sectioninfo.commas = 0; // commas encountered, to handle scaling
  sectioninfo.percent = 0; // times to scale by 100

  for (chpos=0; chpos<format_string.length; chpos++) { // parse
    ch = format_string.charAt(chpos); // get next char to examine
    if (inquote) {
      if (ch == '"') {
        inquote = 0;
        format.operators.push(scfn.commands.copy);
        format.operands.push(quotestr);
        continue;
      }
      quotestr += ch;
      continue;
    }
    if (inbracket) {
      if (ch==']') {
        inbracket = 0;
        bracketdata=FormatNumber.parse_format_bracket(bracketstr);
        if (bracketdata.operator==scfn.commands.separator) {
          sectioninfo.thousandssep = 1; // explicit [,]
          continue;
        }
        if (bracketdata.operator==scfn.commands.date) {
          sectioninfo.hasdate = 1;
        }
        if (bracketdata.operator==scfn.commands.comparison) {
          format.hascomparison = 1;
        }
        format.operators.push(bracketdata.operator);
        format.operands.push(bracketdata.operand);
        continue;
      }
      bracketstr += ch;
      continue;
    }

    if (lastwasslash) {
      format.operators.push(scfn.commands.copy);
      format.operands.push(ch);
      lastwasslash=false;
      continue;
    }

    if (lastwasasterisk) {
      format.operators.push(scfn.commands.copy);
      format.operands.push(ch+ch+ch+ch+ch); // do 5 of them since no real tabs
      lastwasasterisk=false;
      continue;
    }

    if (lastwasunderscore) {
      format.operators.push(scfn.commands.copy);
      format.operands.push(' ');
      lastwasunderscore=false;
      continue;
    }

    if (ingeneral) {
      if ('general'.charAt(ingeneral)==ch.toLowerCase()) {
        ingeneral++;
        if (ingeneral == 7) {
          format.operators.push(scfn.commands.general);
          format.operands.push(ch);
          ingeneral=0;
        }
        continue;
      }
      ingeneral = 0;
    }

    // last char was part of a date placeholder
    if (indate) {
      if (indate.charAt(0)==ch) { // another of the same char
        indate += ch; // accumulate it
        continue;
      }
      format.operators.push(scfn.commands.date); // something else, save date info
      format.operands.push(indate);
      sectioninfo.hasdate=1;
      indate = '';
    }
    if (ampmstr) {
      ampmstr += ch;
      part=ampmstr.toLowerCase();
      if (part!='am/pm'.substring(0,part.length) && part!='a/p'.substring(0,part.length)) {
        ampstr='';
      }
      else if (part=='am/pm' || part=='a/p') {
        format.operators.push(scfn.commands.date);
        format.operands.push(ampmstr);
        ampmstr = '';
      }
      continue;
    }
    if (ch=='#' || ch=='0' || ch=='?') { // placeholder
    if (integerpart) {
      sectioninfo.integerdigits++;
      if (sectioninfo.commas) { // comma inside of integer placeholders
        sectioninfo.thousandssep = 1; // any number is thousands separator
        sectioninfo.commas = 0; // reset count of "thousand" factors
      }
      lastwasinteger = 1;
      format.operators.push(scfn.commands.integer_placeholder);
      format.operands.push(ch);
    }
    else {
      sectioninfo.fractiondigits++;
      format.operators.push(scfn.commands.fraction_placeholder);
      format.operands.push(ch);
    }
  } else if (ch == '.') {
    lastwasinteger = 0;
    format.operators.push(scfn.commands.decimal);
    format.operands.push(ch);
    integerpart = 0;
  } else if (ch === '$') {
    lastwasinteger = 0;
    format.operators.push(scfn.commands.currency);
    format.operands.push(ch);
  } else if (ch==',') {
    if (lastwasinteger) {
      sectioninfo.commas++;
    } else {
      format.operators.push(scfn.commands.copy);
      format.operands.push(ch);
    }
  } else if (ch=='%') {
    lastwasinteger = 0;
    sectioninfo.percent++;
    format.operators.push(scfn.commands.copy);
    format.operands.push(ch);
  } else if (ch=='"') {
    lastwasinteger = 0;
    inquote = 1;
    quotestr = '';
  } else if (ch=='[') {
    lastwasinteger = 0;
    inbracket = 1;
    bracketstr = '';
  } else if (ch=='\\') {
    lastwasslash = 1;
    lastwasinteger = 0;
  } else if (ch=='*') {
    lastwasasterisk = 1;
    lastwasinteger = 0;
  } else if (ch=='_') {
    lastwasunderscore = 1;
    lastwasinteger = 0;
  } else if (ch==';') {
    section++; // start next section
    format.sectioninfo[section] = {}; // create a new section
    sectioninfo = format.sectioninfo[section]; // get reference to info for current section
    sectioninfo.sectionstart = 1 + format.operators.length; // remember where it starts
    sectioninfo.integerdigits = 0; // number of integer-part placeholders
    sectioninfo.fractiondigits = 0; // fraction placeholders
    sectioninfo.commas = 0; // commas encountered, to handle scaling
    sectioninfo.percent = 0; // times to scale by 100
    integerpart = 1; // reset for new section
    lastwasinteger = 0;
    format.operators.push(scfn.commands.section);
    format.operands.push(ch);
  } else if (ch.toLowerCase()=='g') {
    ingeneral = 1;
    lastwasinteger = 0;
  } else if (ch.toLowerCase()=='a') {
    ampmstr = ch;
    lastwasinteger = 0;
  } else if ('dmyhHs'.indexOf(ch)>=0) {
    indate = ch;
  } else {
    lastwasinteger = 0;
    format.operators.push(scfn.commands.copy);
    format.operands.push(ch);
  }
}

// last char was part of unsaved date placeholder
if (indate) {
  format.operators.push(scfn.commands.date);
  format.operands.push(indate);
  sectioninfo.hasdate = 1;
}

return;

}


/* *******************

bracketdata = FormatNumber.parse_format_bracket(bracketstr)

Takes a bracket contents (e.g., "RED", ">10") and returns an operator and operand

bracketdata->{}
.operator
.operand

************************* */

FormatNumber.parse_format_bracket = function(bracketstr) {

  var scfn = FormatNumber;

  var bracketdata={};
  var parts;

  // currency
  if (bracketstr.charAt(0)=='$') {
    bracketdata.operator = scfn.commands.currency;
    parts=bracketstr.match(/^\$(.+?)(\-.+?){0,1}$/);
    if (parts) {
      bracketdata.operand = parts[1] || DefaultCurrency || '$';
    } else {
      bracketdata.operand = bracketstr.substring(1) || DefaultCurrency || '$';
    }
  } else if (bracketstr=='?$') {
    bracketdata.operator = scfn.commands.currency;
    bracketdata.operand = '[?$]';
  } else if (AllowedColors[bracketstr.toUpperCase()]) {
    bracketdata.operator = scfn.commands.color;
    bracketdata.operand = AllowedColors[bracketstr.toUpperCase()];
  } else if (parts=bracketstr.match(/^style=([^']*)$/)) {
    // [style=...]
    bracketdata.operator = scfn.commands.style;
    bracketdata.operand = parts[1];
  }
  else if (bracketstr==',') {
    bracketdata.operator = scfn.commands.separator;
    bracketdata.operand = bracketstr;
  }
  else if (AllowedDates[bracketstr.toUpperCase()]) {
    bracketdata.operator = scfn.commands.date;
    bracketdata.operand = AllowedDates[bracketstr.toUpperCase()];
  }
  else if (parts=bracketstr.match(/^[<>=]/)) { // comparison operator
    parts=bracketstr.match(/^([<>=]+)(.+)$/); // split operator and value
    bracketdata.operator = scfn.commands.comparison;
    bracketdata.operand = parts[1]+':'+parts[2];
  }
  else { // unknown bracket
    bracketdata.operator = scfn.commands.copy;
    bracketdata.operand = '['+bracketstr+']';
  }

  return bracketdata;

}

function text(value, format, currency_char) {
  return FormatNumber.formatNumberWithFormat(value, format, currency_char);
}

// TRIMS returns a string without whitespace at the beginning or end.
function trim(text) {
    if (typeof text !== 'string') {
        return error$2.value;
    }
    return text.trim();
}

// Copyright 2015 JC Fisher

// UPPER converts a string to upper case
function upper(string) {
  return string.toUpperCase()
}

// Find a needle in a table searching horizontally.
function hlookup(needle, table, index=1, exactmatch) {
    if (typeof needle === "undefined" || isblank(needle)) {
        return null;
    }

    if (index > table.length) {
      return error$2.ref
    }

    var needleLower = (needle + '').toLowerCase(),
    row = table[0];

    for (var i = 0; i < row.length; i++){

      if ((exactmatch && row[i]===needle) ||
          ((row[i] == needle) ||
           (typeof row[i] === "string" && row[i].toLowerCase().indexOf(needleLower) != -1) )) {
            return table[index-1][i];
        }
    }

    return error$2.na;
}

// from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes?v=example
function includes(searchElement, searchList, fromIndex) {

  // 1. Let O be ? ToObject(this value).
  if (searchList == null) {
    throw new TypeError('"searchList" is null or not defined');
  }

  var o = Object(searchList);

  // 2. Let len be ? ToLength(? Get(O, "length")).
  var len = o.length >>> 0;

  // 3. If len is 0, return false.
  if (len === 0) {
    return false;
  }

  // 4. Let n be ? ToInteger(fromIndex).
  //    (If fromIndex is undefined, this step produces the value 0.)
  var n = fromIndex | 0;

  // 5. If n ≥ 0, then
  //  a. Let k be n.
  // 6. Else n < 0,
  //  a. Let k be len + n.
  //  b. If k < 0, let k be 0.
  var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

  function sameValueZero(x, y) {
    return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));
  }

  // 7. Repeat, while k < len
  while (k < len) {
    // a. Let elementK be the result of ? Get(O, ! ToString(k)).
    // b. If SameValueZero(searchElement, elementK) is true, return true.
    // c. Increase k by 1.
    if (sameValueZero(o[k], searchElement)) {
      return true;
    }
    k++;
  }

  // 8. Return false
  return false;
}

// index returns the value in a row and column from a 2d array
function index(reference, row_num, column_num=1) {
  var row;

  if (!isarray(reference) || isblank(row_num)) {
    return error$2.value
  }

  if (reference.length < row_num) {
    return error$2.ref
  }

  row = reference[row_num-1];

  if (!isarray(row)) {
    return error$2.value
  }

  if (row.length < column_num) {
    return error$2.ref
  }

  return row[column_num-1];
}

// Copyright 2015 JC Fisher

// LOOKUP find a value in an array.
function lookup() {
    var lookup_value, lookup_array, lookup_vector, results_vector;
    if (arguments.length === 2) { // array form
        var wide = false;

        lookup_value = arguments[0].valueOf();
        lookup_array = arguments[1];

        for (var i = 0; i < lookup_array.length; i++) {
            if (typeof lookup_array[i] !== 'undefined' && lookup_value === lookup_array[i].valueOf()) {
                return lookup_array[i];
            }
        }

    } else if (arguments.length === 3) { // vector form`
        lookup_value = arguments[0].valueOf();
        lookup_vector = arguments[1];
        results_vector = arguments[2];

        for (var i = 0; i < lookup_vector.length; i++) {
            if (typeof lookup_vector[i] !== 'undefined' && lookup_value === lookup_vector[i].valueOf()) {
                return results_vector[i];
            }
        }

    }

    return error.na;

}

// MATCH returns an index in `array_reference` by searching for `lookup_reference`.
function match(lookup_reference, array_reference, matchType) {

  var lookupArray, lookupValue, index, indexValue;

  // Gotta have only 2 arguments folks!
  if (arguments.length === 2) {
    matchType = 1;
  }

  // Find the lookup value inside a worksheet cell, if needed.
  lookupValue = lookup_reference;


  // Find the array inside a worksheet range, if needed.
  if (isarray(array_reference)) {
    lookupArray = array_reference;
  } else {
    return error$2.na;
  }

  // Gotta have both lookup value and array
  if (!lookupValue && !lookupArray) {
    return error$2.na;
  }

  // Bail on weird match types!
  if (matchType !== -1 && matchType !== 0 && matchType !== 1) {
    return error$2.na;
  }

  for (var idx = 0; idx < lookupArray.length; idx++) {
    if (matchType === 1) {
      if (lookupArray[idx] === lookupValue) {
        return idx + 1;
      } else if (lookupArray[idx] < lookupValue) {
        if (!indexValue) {
          index = idx + 1;
          indexValue = lookupArray[idx];
        } else if (lookupArray[idx] > indexValue) {
          index = idx + 1;
          indexValue = lookupArray[idx];
        }
      }
    } else if (matchType === 0) {
      if (typeof lookupValue === 'string') {
        // '?' is mapped to the regex '.'
        // '*' is mapped to the regex '.*'
        // '~' is mapped to the regex '\?'
        if (idx === 0) {
          lookupValue = "^" + lookupValue.replace(/\?/g, '.').replace(/\*/g, '.*').replace(/~/g, '\\?') + "$";
        }
        if (typeof lookupArray[idx] !== "undefined") {
          if (String(lookupArray[idx]).toLowerCase().match(String(lookupValue).toLowerCase())) {
            return idx + 1;
          }
        }
      } else {
        if (typeof lookupArray[idx] !== "undefined" && lookupArray[idx] !== null && lookupArray[idx].valueOf() === lookupValue) {
          return idx + 1;
        }
      }
    } else if (matchType === -1) {
      if (lookupArray[idx] === lookupValue) {
        return idx + 1;
      } else if (lookupArray[idx] > lookupValue) {
        if (!indexValue) {
          index = idx + 1;
          indexValue = lookupArray[idx];
        } else if (lookupArray[idx] < indexValue) {
          index = idx + 1;
          indexValue = lookupArray[idx];
        }
      }
    }
  }

  return index ? index : error$2.na;

};

// VLOOKUP find a needle in a table searching vertically.
function vlookup(needle, table=[], index=1, exactmatch=false) {

    if ( iserror(needle) || isblank(needle) ) {
        return needle;
    }

    for (var i = 0; i < table.length; i++){
        var row = table[i];

        if (index > row.length){
          return error$2.ref
        }

        if ((exactmatch && row[0]===needle) ||
            ((row[0] == needle) ||
             (typeof row[0] === "string" && row[0].toLowerCase().indexOf(needle.toLowerCase()) != -1) )) {
            return (index < (row.length+1) ? row[index-1] : row[0]);
        }
    }

    return error$2.na;

}

// date returns a serial number given a year, month and day.
function date(year, month, day) {
  return serial(new Date(year, month-1, day));
}

// DATEVALUE parses a date string and returns a serial number.
function datevalue(d) {
  return serial(parsedate(d));
}

// DATEDIF return the difference between two dates given a start date, end date and unit.
function datedif(start_date, end_date, unit) {
  var second=1000, minute=second*60, hour=minute*60, day=hour*24, week=day*7;
  start_date = parsedate(start_date),
  end_date = parsedate(end_date)

  var timediff = end_date - start_date;
  if (isnan(timediff)) return NaN;

  switch (unit) {
    case "Y": return end_date.getFullYear() - start_date.getFullYear();
    case "M": return (
      ( end_date.getFullYear() * 12 + end_date.getMonth() )
        -
      ( start_date.getFullYear() * 12 + start_date.getMonth() )
    );
    case "W"  : return Math.floor(timediff / week);
    case "D"   : return Math.floor(timediff / day);
    case "MD"   : return end_date.getdate() - start_date.getdate();
    case "YM" : return end_date.getMonth() - start_date.getMonth();
    case "YD": return new error("NOT IMPLEMENTED");
    default: return undefined;
  }

}

// DAY parses a date string and returns the day of the month.
function day(d) {
  return parsedate(d).getDate()
}

function days360(start_date, end_date, method) {
    method = parsebool(method);
    start_date = parsedate(start_date);
    end_date = parsedate(end_date);

    if (start_date instanceof Error) {
        return start_date;
    }
    if (end_date instanceof Error) {
        return end_date;
    }
    if (method instanceof Error) {
        return method;
    }
    var sm = start_date.getMonth();
    var em = end_date.getMonth();
    var sd, ed;
    if (method) {
        sd = start_date.getDate() === 31 ? 30 : start_date.getDate();
        ed = end_date.getDate() === 31 ? 30 : end_date.getDate();
    } else {
        var smd = new Date(start_date.getFullYear(), sm + 1, 0).getDate();
        var emd = new Date(end_date.getFullYear(), em + 1, 0).getDate();
        sd = start_date.getDate() === smd ? 30 : start_date.getDate();
        if (end_date.getDate() === emd) {
            if (sd < 30) {
                em++;
                ed = 1;
            } else {
                ed = 30;
            }
        } else {
            ed = end_date.getDate();
        }
    }
    return (
      360 * (end_date.getFullYear() - start_date.getFullYear()) + 30 * (em - sm) + (ed - sd)
    );
}

function edate(start_date, months) {
    start_date = parsedate(start_date);

    if (start_date instanceof Error) {
        return start_date;
    }
    if (isNaN(months)) {
        return error.value;
    }
    months = parseInt(months, 10);
    start_date.setMonth(start_date.getMonth() + months);
    return serial(start_date);
};

function eomonth(start_date, months) {
  start_date = parsedate(start_date);

  if (start_date instanceof Error) {
    return start_date;
  }
  if (isNaN(months)) {
    return error$2.value;
  }
  months = parseInt(months, 10);
  return new Date(start_date.getFullYear(), start_date.getMonth() + months + 1, 0);
}

function hour(value) {
    // remove numbers before decimal place and convert fraction to 24 hour scale.
    return trunc((value - trunc(value)) * 24);
}

function minute(value) {
  // calculate total seconds
  var totalSeconds = (value-trunc(value)) * SecondsInDay;
  // calculate number of seconds for hour components
  var hourSeconds = trunc(totalSeconds / SecondsInHour) * SecondsInHour;
  // calculate the number seconds after remove seconds from the hours and convert to minutes
  return trunc( (totalSeconds - hourSeconds) / SecondsInMinute);
}

// MONTH parses a date value and returns the month of the year.
function month(d) {
  return parsedate(d).getMonth() + 1
}

function timevalue(time_text) {
    // The JavaScript new Date() does not accept only time.
    // To workaround the issue we put 1/1/1900 at the front.

    var date = new Date("1/1/1900 " + time_text);

    if (date instanceof Error) {
        return date;
    }

    return (SecondsInHour * date.getHours() +
            SecondsInMinute * date.getMinutes() +
            date.getSeconds()) / SecondsInDay;
};

function now() {
  var d = new Date();
  return datevalue(d.toLocaleDateString()) + timevalue(d.toLocaleTimeString());
};

function second(value) {

  // calculate total seconds
  var totalSeconds = (value-trunc(value)) * SecondsInDay;

  // calculate number of seconds for hour component
  var hourSeconds = trunc(totalSeconds / SecondsInHour) * SecondsInHour;

  // calculate number of seconds in minute component
  var minuteSeconds = trunc((totalSeconds-hourSeconds) / SecondsInMinute) * SecondsInMinute;

  // remove seconds for hours and minutes and round to nearest value
  return Math.round(totalSeconds - hourSeconds - minuteSeconds);
}

function today() {
  var d = new Date();
  return datevalue(d.toLocaleDateString())
};

function time(hour, minute, second) {
  return +((hour*3600 + minute*60 + second) / SecondsInDay).toFixed(15);
}

// YEAR parses a date value and returns the year of the year.
function year(d) {
  return parsedate(d).getFullYear()
}

function yearfrac(start_date, end_date, basis) {
  start_date = parsedate(start_date);
  if (start_date instanceof Error) {
    return start_date;
  }
  end_date = parsedate(end_date);
  if (end_date instanceof Error) {
    return end_date;
  }

  basis = basis || 0;
  var sd = start_date.getDate();
  var sm = start_date.getMonth() + 1;
  var sy = start_date.getFullYear();
  var ed = end_date.getDate();
  var em = end_date.getMonth() + 1;
  var ey = end_date.getFullYear();

  function isLeapYear(year) { return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0)); }
  function daysBetween(a, b) { return serial(b) - serial(a) }

  switch (basis) {
    case 0:
    // US (NASD) 30/360
    if (sd === 31 && ed === 31) {
      sd = 30;
      ed = 30;
    } else if (sd === 31) {
      sd = 30;
    } else if (sd === 30 && ed === 31) {
      ed = 30;
    }
    return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;
    case 1:
    // Actual/actual
    var feb29Between = function(date1, date2) {
      var year1 = date1.getFullYear();
      var mar1year1 = new Date(year1, 2, 1);
      if (isLeapYear(year1) && date1 < mar1year1 && date2 >= mar1year1) {
        return true;
      }
      var year2 = date2.getFullYear();
      var mar1year2 = new Date(year2, 2, 1);
      return (isLeapYear(year2) && date2 >= mar1year2 && date1 < mar1year2);
    };
    var ylength = 365;
    if (sy === ey || ((sy + 1) === ey) && ((sm > em) || ((sm === em) && (sd >= ed)))) {
      if ((sy === ey && isLeapYear(sy)) ||
      feb29Between(start_date, end_date) ||
      (em === 1 && ed === 29)) {
        ylength = 366;
      }
      return daysBetween(start_date, end_date) / ylength;
    }
    var years = (ey - sy) + 1;
    var days = (new Date(ey + 1, 0, 1) - new Date(sy, 0, 1)) / 1000 / 60 / 60 / 24;
    var average = days / years;
    return daysBetween(start_date, end_date) / average;
    case 2:
    // Actual/360
    return daysBetween(start_date, end_date) / 360;
    case 3:
    // Actual/365
    return daysBetween(start_date, end_date) / 365;
    case 4:
    // European 30/360
    return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;
  }
};

// SUM a given list of `numbers`
function sum(...numbers) {
    return reduce(flatten(flatten(numbers)), (a, b) => {
      if (typeof b !== 'number') { return error$2.value }
      return a + b
    });
}

// AVERAGE computes sum of items divided by number of items
function average(...items) {

  // compute sum all of the items.
  var v = sum(...items)

  // return sum when computed error.
  if (iserror(v)) {
    return v;
  }

  // return sum divided by item count
  return  v / items.length;
}

// MIN returns the smallest number from a `list`.
function min(...list) {

  var values = flatten( list )
  if (values.length === 0) return;
  return reduce( values, (min, next) => {
    if (isblank(min)) return next;
    else if (isnumber(next)) return Math.min(min, next);
    else return min;
  });
}

// MAX returns the largest number from a `list`.
function max(...list) {

  var values = flatten( list )
  if (values.length === 0) return;
  return reduce( values, (max, next) => {
    if (isblank(max)) return next;
    else if (isnumber(next)) return Math.max(max, next);
    else return max;
  });
}

// FILTER limits a range based on arrays of boolean values.
function filter(range, ...filters) {

  // A filter is an array of true/false values.
  // The filter may be for rows or for columns but not both.
  // A array filter may only filter a range that covers a single row or a single column.

  function makefilter() {
    return function(value, index) {
      return reduce( filters, function( previousValue, currentValue ) {
        if (previousValue === false ) {
          return false;
        } else {
          return branch(
            isarray(currentValue),
            () => currentValue[index],
            isfunction(currentValue),
            () => currentValue( value, index ),
            istext(currentValue),
            () => run(currentValue, value),
            error$2.na
          )
        }
      }, true);
    }
  }

  return range.filter( makefilter() )

}

// Copyright 2015 JC Fisher

// isobject returns true when `value` is an object or function.
function isobject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
};

// Functions for each operator.
let filterTypes = {

  $noop: () => () => false,
  $eq: (queryVal) => (row, field) => eq(row[field], queryVal),
  $ne: (queryVal) => (row, field) => ne(row[field], queryVal),
  $gt: (queryVal) => (row, field) => gt(row[field], queryVal),
  $gte: (queryVal) => (row, field) => gte(row[field], queryVal),
  $lt: (queryVal) => (row, field) => lt(row[field], queryVal),
  $lte: (queryVal) => (row, field) => lte(row[field], queryVal),
  $in: (queryVal) => (row, field) => isarray(queryVal) && includes(row[field], queryVal),
  $nin: (queryVal) => (row, field) => isarray(queryVal) && !includes(row[field], queryVal),
  $text: (queryVal) => (row, field) => search(queryVal, row[field]) > 0,
  $exists: (queryVal) => (row, field) => istruthy(queryVal) ? row.hasOwnProperty(field) : !row.hasOwnProperty(field),

  $and: (queryVal) => (row, field) => true,
  $or: (queryVal) => (row, field) => true

}

// Run the filter against the data with the settings.
function query(data, query) {

  let comparison = (field, op, value) => row => (filterTypes[op] || filterTypes['$noop'])(value)(row, field)

  let comparator = (list, key) => row => branch(
    isobject(list[key]),
    () => and(
      ...map( keys(list[key]), (d) => {
        return comparison( key, d, list[key][d] )(row)
      })
    ),
    () => comparison( key, '$eq', list[key])(row)
  )

  let comparisonGroup = (row, list, key, op=and) => {

    if (!isarray(list[key])) {
      throw new Error(`$${op.name} expects array!`);
    }

    return op(
      ...map(
        list[key],
        d => op( ...map( keys(d), e => comparator(d, e)(row) ))
      )
    )

  }

  let composeQuery = (list) => reduce(
    keys(list),
    (funcs, key) => funcs.concat(
      (row) =>
        branch(
          key === '$and',
          () => comparisonGroup(row, list, key, and),
          key === '$or',
          () => comparisonGroup(row, list, key, or),
          () => comparator(list, key)(row)
        )
    ),
    []
  );

  // Compose a list of functions to filter each field.
  let funcs = composeQuery(query);

  // Execute the filter on the data.
  return filter(
    data,
    // map each filter function to true/false values for each row.
    ...map( funcs, filter => map( data, row => filter(row) ) )
  )
}

function fv(rate, periods, payment, value=0, type=0) {

  // is this error code correct?
  if (isblank(rate)) return error$2.na
  if (isblank(periods)) return error$2.na
  if (isblank(payment)) return error$2.na

  var fv;
  if (rate === 0) {
    fv = value + payment * periods;
  } else {
    var term = Math.pow(1 + rate, periods);
    if (type === 1) {
      fv = value * term + payment * (1 + rate) * (term - 1) / rate;
    } else {
      fv = value * term + payment * (term - 1) / rate;
    }
  }
  return -fv;
};

function nper(rate, pmt, pv, fv, type) {
  var log,
  result;
  rate = parseFloat(rate || 0);
  pmt = parseFloat(pmt || 0);
  pv = parseFloat(pv || 0);
  fv = (fv || 0);
  type = (type || 0);

  log = function(prim) {
    if (isnan(prim)) {
      return Math.log(0);
    }
    var num = Math.log(prim);
    return num;
  }

  if (rate == 0.0) {
    result = (-(pv + fv)/pmt);
  } else if (type > 0.0) {
    result = (log(-(rate*fv-pmt*(1.0+rate))/(rate*pv+pmt*(1.0+rate)))/(log(1.0+rate)));
  } else {
    result = (log(-(rate*fv-pmt)/(rate*pv+pmt))/(log(1.0+rate)));
  }

  if (isnan(result)) {
    result = 0;
  }

  return result;
}

// Copyright 2015 JC Fisher

function npv(rate, ...values) {
    rate = rate * 1;
    var factor = 1,
        sum = 0;

    for(var i = 0; i < values.length; i++) {
        var factor = factor * (1 + rate);
        sum += values[i] / factor;
    }

    return sum;
}

// PMT returns a loan payment
function pmt(rate, periods, present, future = 0, type = 0) {

  if (!isnumber(rate) || !isnumber(periods)) {
    return error$2.value;
  }

  if (rate === 0) {
    return -((present + future) / periods);
  } else {
    var term = Math.pow(1 + rate, periods);
    if (type === 1) {
      return -((future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate));
    } else {
      return -(future * rate / (term - 1) + present * rate / (1 - 1 / term));
    }
  }

};

function pv(rate, periods, payment, future=0, type=0) {

  // is this error code correct?
  if (isblank(rate)) return error$2.na
  if (isblank(periods)) return error$2.na
  if (isblank(payment)) return error$2.na

  if (rate === 0) {
    return -payment * periods - future;
  } else {
    return (((1 - Math.pow(1 + rate, periods)) / rate) * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods);
  }
};

// BIN2DEC converts binary string into decimal value
function bin2dec(value) {
    var valueAsString;

    if (typeof value === "string") {
        valueAsString = value;
    } else if (typeof value !== "undefined") {
        valueAsString = value.toString();
    } else {
        return error$2.NA;
    }

    if (valueAsString.length > 10) return error$2.NUM;

    // we subtract 512 when the leading number is 0.
    if (valueAsString.length === 10 && valueAsString[0] === '1') {
        return parseInt(valueAsString.substring(1), 2) - 512;
    }

    // Convert binary number to decimal with built-in facility
    return parseInt(valueAsString, 2);

};

// based on https://github.com/sutoiku/formula.js/blob/mast../src/engineering.js
function dec2bin(input, places) {

  // exit if input is an error
  if (input instanceof Error) {
    return number;
  }

  // cast input to number
  var number = parseInt(input);

  if (!/^-?[0-9]{1,3}$/.test(number) || isnan(number)) {
    return error$2.value;
  }

  // Return error.if number is not decimal, is lower than -512, or is greater than 511
  if (number < -512 || number > 511) {
    return error$2.num;
  }

  // Ignore places and return a 10-character binary number if number is negative
  if (number < 0) {
    return '1' + rept('0', 9 - (512 + number).toString(2).length) + (512 + number).toString(2);
  }

  // Convert decimal number to binary
  var result = parseInt(number, 10).toString(2);

  // Return binary number using the minimum number of characters necessary if places is undefined
  if (typeof places === 'undefined') {
    return result;
  } else {
    // Return error.if places is nonnumeric
    if (!/^-?[0-9]{1,3}$/.test(places) || isnan(places)) {
      return error$2.value;
    }

    // Return error.if places is negative
    if (places < 0) {
      return error$2.num;
    }

    // Truncate places in case it is not an integer
    places = Math.floor(places);

    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
    return (places >= result.length) ? rept('0', places - result.length) + result : error$2.num;
  }
}

// OCT2DEC converts a octal value into a decimal value.
function oct2dec(octalNumber) {
  // Credits: Based on implementation found in https://gist.github.com/ghalimi/4525876#file-oct2dec-js
  // Return error.when number passed in is not octal or has more than 10 digits
  if (!/^[0-7]{1,10}$/.test(octalNumber)) return error$2.num;

  // Convert octal number to decimal number
  var nonNegativeDecimalNumber = parseInt(octalNumber, 8);

  // Returns the corresponding decimal number
  // Two's Complement Decimal Range: -(2^N-1) to (2^N-1 - 1) where N=30 (N = number of bits) and ^ means raised to the power of
  // 2^N-1 = 2^(30 - 1) = 2^29 = 536870912
  // 2^N-1 - 1 = 536870912 - 1 = 536870911
  // 2^N = 2^30 = 1073741824
  // Two's Complement Decimal Range: [-536870912,536870911]
  // Largest octal number allowed: 7777777777 which in decimal is 1073741823 = 2^N - 1
  // Case 1: Negative Range
  //  if nonNegativeDecimalNumber >= 2^N-1, then return (nonNegativeNumber - 2^N)
  //  Smallest Number: 2^N-1 - 2^N = 2^N-1 - 2*2^N-1 = 2^N-1 * (1 - 2) = 2^N-1 * (-1) = -2^N-1
  //  Largest Number: (2^N - 1) - (2^N) = (2^N - 2^N) - 1 = -1
  //  Range: [-2^N-1, -1] = [-536870912, -1]
  //
  // Smallest octal number allowed: 0 which in decimal is 0
  // Case 2: Non-Negative Range
  //   Range: [0, 2^N-1 - 1] = [0, 536870911]

  return (nonNegativeDecimalNumber >= 536870912) ? nonNegativeDecimalNumber - 1073741824 : nonNegativeDecimalNumber;
}

// pluck a property from a list of objects.
function pluck(prop, list) {

  // Ensure that the list is an array.
  if (!isarray(list)) {
    return error$2.na
  }

  // Map the list to the property.
  return map( list, d => d[prop] )
}

// INT returns true when a needle is found in a list.
function some(needle, list) {

  // Return `#NA!` when the needle and list are blank.
  if ( isblank(needle) && isblank(list) ) {
    return error$2.na;
  }

  // Return `#NA!` when the list is not an array.
  if (!isarray(list)) {
    return error$2.na;
  }

  // Return true when some of the values match the needle.
  return list.some(n => eq(n, needle) )
}

// SORT a reference or an array.
//
// The criteria may use 1 of several forms:
//
// sort(reference(reference: Array, ...criteria : List<string>)
// sort(reference(reference: Range, ...criteria : List<string>)
//
// The List<function> will be reduced into a single function.
//
// The list<string> will also be reduced into a single function which
// interprets the strings as pairs. The odd items are fields and the
// even ones are direction (ASC|DESC).
function sort(ref, ...criteria) {

  // reduce the criteria array into a function
  let makeComparer = () => {
    return function(a, b) {
      var result = 0;
      for (var i = 0; i < criteria.length; i+2) {
        let field = (typeof criteria[i] === 'string' ? criteria[i] : criteria[i] - 1),
            order = criteria[i+1];

        if (a[field] < b[field]) {
          return order ? -1 : 1;
        } else {
          return order ? 1 : -1;
        }

      }

      return result;

    }

  }

  if (isref(ref) || isarray(ref)) {
    return ref.sort( makeComparer() );
  }

  return error$2.na;

}

// UNIQUE reduces an `array` into an array without duplicate values.
function unique(array) {
  return reduce( array, function(p, c) {
    if (p.indexOf(c) < 0) p.push(c);
    return p;
  }, [])
}

// CHANGED computes the list of keys that are different between two objects.
function changed(a, b) {

  // Compute the keys in object a and b.
  var keysA = keys(a),
  keysB = keys(b)

  // Find the unique set of properties comparing a to b and b to a.
  return unique(
    keysA
    .filter( n => a[n] !== b[n])
    .concat(
      keysB
      .filter( n => a[n] !== b[n])
    )
  )
}

function diff(a, b) {
  let keysA = keys(a),
  keysB = keys(b),
  InA = keysB.filter(n => keysA.indexOf(n) > -1),
  NotInA = keysB.filter(n => keysA.indexOf(n) === -1),
  NotInB = keysA.filter(n => keysB.indexOf(n) === -1),
  Diff = InA.filter( n => a[n] !== b[n])

  return {
    unique_left: NotInA,
    unique_right: NotInB,
    diff: reduce( Diff, (x, y) => {
      var diff = { }
      diff[y] = { left: a[y], right: b[y]}
      return assign({}, x, diff)
    }, {})
  }
}

// SELECT fields from object
function select(fields, body) {
  // non-json
  if (!body || 'object' != typeof body) return;

  // check for fields
  if (!fields) return;

  // split
  if ('string' == typeof fields) fields = fields.split(/ *, */);

  // fields array
  if (isarray(body)) {
    return body.map(function(obj){
      return reduce( fields, function(ret, key){
        ret[key] = obj[key];
        return ret;
      }, {});
    });

    return;
  }

  // fields object
  return reduce( fields, function(ret, key){
    ret[key] = body[key];
    return ret;
  }, {});
}

// CLEAN accepts an object and remove properties that are blank.
function clean(obj) {
  // Compute keys where value is non blank.
  let keys$$ = keys(obj).filter( n => !isblank(obj[n]) )

  // Compute object with only non-blank keys.
  return select( keys$$, obj )
}

// get a property (p) from an object (o)
function get(p, o) {
  return o[p]
}

// CELLINDEX computes the index for row and column in a 2 dimensional array.
function cellindex(row, col) {
  // Multiple row by maximum columns plus the col.
  return Math.floor( (row * MaxCols) + col );
}

// Convert letter to number (e.g A -> 0)
function columnnumber(column) {

  if (!istext(column)) {
    return error$2.value
  }

  // see toColumn for rant on why this is sensible even though it is illogical.
  var s = 0, secondPass;

  if (column.length > 0) {

    s = column.charCodeAt(0) - 'A'.charCodeAt(0);

    for (var i = 1; i < column.length; i++) {
      // compensate for spreadsheet column naming
      s+=1
      s *= 26;
      s += column.charCodeAt(i) - 'A'.charCodeAt(0);
      secondPass = true;
    }

    return s;

  }

  return error$2.value;

}

// COLUMN return the column number that corresponds to the reference.
function column(value) {

  // Return `#VALUE!` when the value is not a reference.
  if (!isref(value)) {
    return error$2.value;
  }

  // Run the COLUMNNUMBER and convert to base 1.
  return columnnumber(value.column) + 1;
}

// Convert index to letter (e.g 0 -> A)
function columnletter( index ) {

  if (!isnumber(index)) {
    return error$2.value
  }

  // The column is determined by applying a modified Hexavigesimal algorithm.
  // Normally BA follows Z but spreadsheets count wrong and nobody cares.

  // Instead they do it in a way that makes sense to most people but
  // is mathmatically incorrect. So AA follows Z which in the base 10
  // system is like saying 01 follows 9.

  // In the least significant digit
  // A..Z is 0..25

  // For the second to nth significant digit
  // A..Z is 1..26

  var converted = ""
  ,secondPass = false
  ,remainder
  ,value = Math.abs(index);

  do {
    remainder = value % 26;

    if (secondPass) {
      remainder--;
    }

    converted = String.fromCharCode((remainder + 'A'.charCodeAt(0))) + converted;
    value = Math.floor((value - remainder) / 26);

    secondPass = true;
  } while (value > 0);

  return converted;

}

// Copyright 2015 JC Fisher

function decodebase64(str) {

  if (typeof window !== 'undefined' && typeof atob !== 'undefined') {
    return window.atob(str)
  } else if (typeof module !== 'undefined' && module.exports) {
    return (new Buffer(str, 'base64')).toString()
  } else {
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

    function InvalidCharacterError(message) {
      this.message = message;
    }

    InvalidCharacterError.prototype = new Error();
    InvalidCharacterError.prototype.name = 'InvalidCharacterError';

     function atob(input) {

      var str = String(input).replace(/=+$/, '');
      if (str.length % 4 == 1) {
        throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
      }
      for (
        // initialize result and counters
        var bc = 0, bs, buffer, idx = 0, output = '';
        // get next character
        buffer = str.charAt(idx++);
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
          // and if not first of each 4 characters,
          // convert the first 8 bits to one ascii character
          bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
        ) {
          // try to find character in table (0-63, not found => -1)
          buffer = chars.indexOf(buffer);
        }
        return output;
      }

    return atob(str)

  }
}

function decodejwt(token) {

  function b64DecodeUnicode(str) {
      return decodeURIComponent(Array.prototype.map.call(decodebase64(str), function(c) {
          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
      }).join(''));
  }

  return JSON.parse( b64DecodeUnicode( token.split('.')[1] ) )
}

// Copyright 2015 JC Fisher

// credit to http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
// rfc4122 version 4 compliant solution

// Generate a globally unique identifier
function guid(){
  var guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
    return v.toString(16);
  });
  return guid;
};

// Copyright 2015 JC Fisher

function int(value) {
  return Math.floor(value)
}

// INDEX2COL computes the row given a cell index
function index2row(index) {
  return Math.floor(index / MaxCols);
}

// INDEX2COL computes the column given a cell index
function index2col(index) {
  return index - (index2row(index) * MaxCols);
}

function numbers(...values) {
  return reduce(
    values,
    (p, v) => isnumber(v) ? p.concat(v) : p,
    []
  )
}

// REF accepts top and bottom and returns a reference object. It encapsulates a cell or a range.
function ref$1(top, bottom) {

  // The index must be a number
  if (!isnumber(top) && !isfunction(top)) {
    return error$2.value
  }

  if (isblank(bottom)) {
    bottom = top
  }

  var getTop = () => isfunction(top) ? top() : top
  var getBottom = () => isfunction(bottom) ? bottom() : bottom

  return {

    get _isref(){
      return true
    },

    get top() {
      return getTop()
    },

    get bottom() {
      return getBottom()
    },

    // Returns row (rowIndex plus 1)
    get row() {
      return index2row( getTop() ) + 1;
    },

    // Returns rowIndex (base 0)
    get rowIndex() {
      return index2row( getTop() )
    },

    // Returns column letter
    get column() {
      return columnletter( index2col( getTop() ) )
    },

    // Returns column index
    get columnIndex() {
      return index2col( getTop() )
    },

    // Returns row (rowIndex plus 1)
    get bottomRow() {
      return index2row( getBottom() ) + 1;
    },

    // Returns rowIndex (base 0)
    get bottomRowIndex() {
      return index2row( getBottom() )
    },

    // Returns column letter
    get bottomColumn() {
      return columnletter( index2col( getBottom() ) )
    },

    // Returns column index
    get bottomColumnIndex() {
      return index2col( getBottom() )
    },

    // The cell id puts the whole table into a single dimension. It simply needs to be between the topLeft and the bottomRight to qualify.
    hit(index) {

      // Return `#NA!` when index is negative.
      if (index < 0) return error$2.na

      // Check if value is inside range from top to bottom, inclusive.
      return (
        ( index >= getTop() ) &&
        ( index <= getBottom() )
      );
    },

    get size() {
      return 1 + (getBottom() - getTop())
    },

    // Return array with every cell index
    get cells() {
      return Array.apply(
        getTop(),
        Array( 1 + (getBottom() - getTop()) )
      )
      .map( (x, y) => y + getTop())
    },

    // Return array with every row
    get rows() {
      return unique(
        Array.apply(
          getTop(),
          Array( 1 + (getBottom() - getTop()) )
        )
        .map( (x, y) => index2row(y + getTop()))
      )
    }

  }
}

// define `cond` alias for branch
const cond = branch

const ifBlank = ifblank

const ifEmpty = ifempty

const ifError = iferror

const ifNA = ifna

const isArray = isarray

const isBlank = isblank

const isbool = isboolean
const isBoolean = isboolean
const isBool = isboolean

const isDate = isdate

const isEmail = isemail

const isEmpty = isempty

const isError = iserror

const isEven = iseven

const isFalsy = isfalsy

const isFunction = isfunction

const isLeapYear = isleapyear

const isNA = isna

const isNaN$1 = isnan

const isNumber = isnumber

const isOdd = isodd

const isoWeekNum = isoweeknum

const isRef = isref

const isText = istext

const isTruthy = istruthy

const isURL = isurl

const isWholeNumber = iswholenumber
const isInteger = iswholenumber

const concat = concatenate

const numberValue = numbervalue

const parseBool = parsebool

const parseDate = parsedate

const parseQuery = parsequery

const template = substituteAll

const dateValue = datevalue

const cellIndex = cellindex

const columnLetter = columnletter

const decodeBase64 = decodebase64
const atob = decodebase64

const decodeJWT = decodejwt

var functions = {
  run,
  compile,
  abs,
  acos,
  add,
  and,
  atob,
  average,
  bin2dec,
  branch,
  cellIndex,
  cellindex,
  changed,
  char,
  choose,
  clean,
  code,
  column,
  columnLetter,
  columnletter,
  columnnumber,
  concat,
  concatenate,
  cond,
  cos,
  date,
  dateValue,
  datedif,
  datevalue,
  day,
  days360,
  dec2bin,
  decodeBase64,
  decodeJWT,
  decodebase64,
  decodejwt,
  diff,
  divide,
  edate,
  eomonth,
  eq,
  exact,
  filter,
  find,
  flatten,
  fv,
  get,
  gt,
  gte,
  guid,
  hlookup,
  hour,
  ifBlank,
  ifEmpty,
  ifError,
  ifNA,
  ifblank,
  ifempty,
  iferror,
  ifna,
  includes,
  index,
  index2col,
  index2row,
  int,
  isArray,
  isBlank,
  isBool,
  isBoolean,
  isDate,
  isEmail,
  isEmpty,
  isError,
  isEven,
  isFunction,
  isInteger,
  isLeapYear,
  isNA,
  isNumber,
  isOdd,
  isRef,
  isText,
  isWholeNumber,
  isarray,
  isblank,
  isbool,
  isboolean,
  isdate,
  isemail,
  isempty,
  iserror,
  iseven,
  isfalsy,
  isfunction,
  isleapyear,
  isna,
  isnan,
  isnumber,
  isoWeekNum,
  isodd,
  isoweeknum,
  isref,
  istext,
  istruthy,
  isurl,
  iswholenumber,
  join,
  left,
  len,
  lookup,
  lower,
  lt,
  lte,
  map,
  match,
  max,
  min,
  minute,
  month,
  multiply,
  n,
  ne,
  not,
  now,
  nper,
  npv,
  numberValue,
  numbers,
  numbervalue,
  oct2dec,
  or,
  parseBool,
  parseDate,
  parseQuery,
  parsebool,
  parsedate,
  parsequery,
  pi,
  pluck,
  pmt,
  power,
  proper,
  pv,
  query,
  reduce,
  ref: ref$1,
  replace,
  rept,
  right,
  round,
  roundup,
  search,
  second,
  select,
  serial,
  sin,
  some,
  sort,
  split,
  substitute,
  substituteAll,
  subtract,
  sum,
  surroundKeys,
  tan,
  tau,
  template,
  text,
  time,
  timevalue,
  today,
  trim,
  trunc,
  unique,
  upper,
  vlookup,
  xor,
  year,
  yearfrac,
}

export default functions;